<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>profile on 世界的过客</title><link>https://laujay.com/tags/profile/</link><description>Recent content in profile on 世界的过客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>Copyright &amp;copy; 2016 ~ 2021 - Jay Lau|Theme by [kiera](https://github.com/funkydan2/hugo-kiera)</copyright><lastBuildDate>Sun, 27 Nov 2016 19:24:16 +0800</lastBuildDate><atom:link href="https://laujay.com/tags/profile/index.xml" rel="self" type="application/rss+xml"/><item><title>Mysql 全表扫描</title><link>https://laujay.com/posts/mysql-full-table-scan/</link><pubDate>Sat, 12 Jun 2021 23:15:49 +0800</pubDate><guid>https://laujay.com/posts/mysql-full-table-scan/</guid><description>&lt;h2 id="背景">背景&lt;/h2>&lt;p>​技术栈是Django ORM + MySQL&lt;/p>&lt;p>​已有的项目，历史原因，Django orm的model里充满了&lt;code>index=True, null=True&lt;/code>, 并且各种操作导致全表扫描特别多。&lt;/p>&lt;h2 id="从innodb的索引说起">从InnoDB的索引说起&lt;/h2>&lt;p>​在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。&lt;/p>&lt;p>​每一个索引在InnoDB里对应一棵B+树，所以索引就是在利用树的结构加速扫描，索引分为主键索引(聚簇索引)和普通索引（二级索引）。行为上的差别是，前者只需要搜索主键B+树，后者需要先搜索该二级索引B+树然后得到ID再搜索主键B+树，也就是普通索引需要回表（查第二次）。更多的细节就不再赘述，那个不是本文的重点。&lt;/p>&lt;h2 id="索引的建立">索引的建立&lt;/h2>&lt;p>基于回表这个操作，对于常用的值，为了减少可以利用覆盖索引的方式，建立联合索引，并且通过规划联合索引的顺序来减少索引数， 不需要回表来提高性能，当然会造成索引树的维护问题，这个需要权衡。&lt;/p>&lt;p>我们的业务表里的很多字段是字符串类型的，并且很多做了联合索引，这里就存在一个问题了。索引的值越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。&lt;/p>&lt;p>更糟糕的是，很多列是&lt;code>null=True&lt;/code> 这就引申出另外一个问题了，索引以及联合索引是否能为null。&lt;/p>&lt;p>关于null是否能作为索引列的值，或者换个说法，索引列是否能为null，先上官方文档：&lt;/p>&lt;blockquote>&lt;p>You can add an index on a column that can have NULL values if you are using the MyISAM, InnoDB, or MEMORY storage engine. Otherwise, you must declare an indexed column NOT NULL, and you cannot insert NULL into the column.&lt;/p>&lt;/blockquote>&lt;p>文档说索引在引擎是InnoDB，MyISAM，MEMORY的情况下是可以为null的，然后还有如&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html">这里所述&lt;/a> 这种索引能够走的前提是你采用is null来判断。最后，如果不采用覆盖索引的方式，&lt;code>select * from xxx&lt;/code> 的话，那么如果数据量少，mysql的优化器可能采用全表扫描。&lt;/p>&lt;p>这是我们代码里的另一类问题，因为各种原因导致的不走索引。&lt;/p>&lt;h3 id="全表扫描的场景">全表扫描的场景&lt;/h3>&lt;ul>&lt;li>&lt;p>在 where 子句中使用 != 操作符，引擎放弃使用索引而进行全表扫描&lt;/p>&lt;/li>&lt;li>&lt;p>在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描&lt;/p>&lt;/li>&lt;li>&lt;p>in 和 not in&lt;/p>&lt;/li>&lt;li>&lt;p>like模糊查询&lt;/p>&lt;/li>&lt;li>&lt;p>在where子句中对字段进行函数操作&lt;/p>&lt;/li>&lt;li>&lt;p>select * from xx&lt;/p>&lt;/li>&lt;li>&lt;p>联合索引中的没利用最左前缀匹配原则&lt;/p>&lt;/li>&lt;/ul>&lt;p>由于情况太多。只列举了我们代码里出现情况。&lt;/p>&lt;h2 id="总结">总结&lt;/h2>&lt;p>​当发现你的代码里出现以上情况之一建议优化，但是不要盲目优化，应该先采profiler工具，以Django为例是增加Django-silk之后， 获取到数据，权衡利弊之后再去做调整。&lt;/p></description></item><item><title>Celery踩坑记</title><link>https://laujay.com/posts/celery-note/</link><pubDate>Thu, 06 May 2021 20:02:10 +0800</pubDate><guid>https://laujay.com/posts/celery-note/</guid><description>&lt;p>背景是，Django+Celery， 但是Broker选的Redis，我也不知道为啥是Redis反正就是Redis了。&lt;/p>&lt;p>Celery出了名的坑，但是其实没啥特别好的代替就只能用了，内存泄漏这些常见问题就不记录了。反正定时重启worker大法好。&lt;/p>&lt;h2 id="celery-task-重复执行">Celery task 重复执行&lt;/h2>&lt;p>​ 场景是，会有一组，延迟任务，任务中凡是小于一个小时的delay的都没事，超过的都有问题。开始初步排查认为是visibility_timeout用了默认，因为延迟了1个小时没执行就没有ack，超时重新下发的问题，于是修改了该参数，改为48小时，因为有部分会延迟很长。&lt;/p>&lt;p>​ 但是并没有解决该问题，之后又复现了。这次将对应的整套的log全从k8s里捞出来，对比时间段，发现是重复生产了。一摸一样的task_id生产了好几次。eta都是一样，但是任务receive的时间差在毫秒级。经过搜索结论是，用redis就是会产生这种问题。换成rabbitmq就好了。问题是不想增加中间件了。最后只能让组里的小姐姐撸一个redis锁搞定。因为反正eta在差不多时间，5分钟的锁足够了。&lt;/p>&lt;h2 id="error-104-while-writing-to-socket">Error 104 while writing to socket&lt;/h2>&lt;p>​ 场景是，测试服，Docker跑的Redis长时间运行之后。任务不执行，上去一看疯狂报这种错。直接贴Google里查了下，官方库的issue里发现了解决方案&lt;a href="https://github.com/celery/celery/issues/4867">github/celery&lt;/a>， 原因是Redis的缓冲区配置的问题。那么直接修改即可，我目前的做法是启动的时候直接将其全设置为0，因为只是开发环境。更具体的需要查看Redis的文档，以下&lt;code>slave&lt;/code>需要修改为&lt;code>replica&lt;/code>，因为政治因素，高版本的Redis不再使用slave这一词汇了。&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">client-output-buffer-limit normal &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>client-output-buffer-limit slave &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>client-output-buffer-limit pubsub &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Python的幕后#1: CPython VM 是如何工作的</title><link>https://laujay.com/posts/how-the-cpython-vm-works/</link><pubDate>Fri, 01 Jan 2021 10:20:20 +0800</pubDate><guid>https://laujay.com/posts/how-the-cpython-vm-works/</guid><description>&lt;blockquote>&lt;p>&lt;a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-1-how-the-cpython-vm-works/">原文&lt;/a>&lt;/p>&lt;p>本文已获原文作者&lt;a href="https://tenthousandmeters.com/about/">Victor Skvortsov&lt;/a>授权&lt;/p>&lt;/blockquote>&lt;h2 id="引言">引言&lt;/h2>&lt;p>你是否想过 当你用&lt;code>python&lt;/code>命令执行你的程序的时候, 它做了什么?&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ python script.py&lt;/code>&lt;/pre>&lt;/div>&lt;p>这篇文章是一系列试图回答这个问题文章的开端。我们将会深入CPython的内部(这是Python最流行的实现)。这样我们将更深入的了解语言本身。这是本系列文章的主要目的。如果你熟悉Python和C，但是并不熟悉CPython源码，那么你可能你会发现本文很有趣。&lt;/p>&lt;h2 id="什么是cpython并且为什么有人想要学习它呢">什么是CPython并且为什么有人想要学习它呢?&lt;/h2>&lt;p>让我们从众所周知的地方开始谈起。 CPython是C语言实现的Python解释器。它是Python的一种实现，其他的实现有PyPy，Jython，IronPython等等。CPython是最原始，维护最久和使用最广的一种实现。&lt;/p>&lt;p>CPython实现了Python，但是什么是Python? 一个简单的回答是：Python是一种编程语言。当更近一步提出相同含义的问题时，答案变得更加具体：什么定义了Python是什么？ Python与C之类的语言不同，它没有正式的规范。 最接近它的是Python语言参考，它开始是以下内容:&lt;/p>&lt;blockquote>&lt;p>当我尝试尽可能精确时，我选择对语法和词法分析以外的所有内容使用英语而不是正式的规范。 这应该使普通读者更容易理解文档，但会存在歧义。 因此，如果您是来自火星并试图仅通过本文档重新实现Python，则您可能不得不猜测，实际上您可能最终会实现完全不同的语言。 另一方面，如果您正在使用Python，并且想知道关于该语言特定区域的确切规则是什么，那么您肯定可以在这里找到它们。&lt;/p>&lt;/blockquote>&lt;p>因此，Python并非仅由其语言参考来定义。说Python是由其参考实现CPython定义的，这也是错误的，因为有些实现细节不是该语言的一部分。依赖引用计数的垃圾收集器就是一个例子。 由于没有单一的事实来源，因此我们可以说Python的一部分是由Python语言参考定义的，另一部分是由其主要实现CPython定义的。&lt;/p>&lt;p>这种说法似乎有些古怪，但我认为弄清这个问题对我们将要研究的主题至关重要。 但是，您可能仍然想知道为什么我们应该研究它。 除了好奇心外，我还发现以下原因:&lt;/p>&lt;ul>&lt;li>&lt;p>纵览全貌可以更深入地了解该语言。 如果您了解Python的某些实现细节，那么掌握Python的某些特性就容易得多。&lt;/p>&lt;/li>&lt;li>&lt;p>语言实现细节在实践中很重要。 当人们想了解语言的适用性及其局限性，估计性能或检测对效率的影响时，对象的存储方式，垃圾收集器的工作方式以及如何协调多个线程是非常重要的主题。&lt;/p>&lt;/li>&lt;li>&lt;p>CPython提供了Python / C API，该API允许使用C扩展Python并将Python嵌入C中。要有效地使用此API，程序员需要对CPython的工作方式有充分的了解。&lt;/p>&lt;/li>&lt;/ul>&lt;h2 id="了解cpython如何工作需要什么">了解CPython如何工作需要什么?&lt;/h2>&lt;p>CPython的设计易于维护。 新手当然可以期望能够阅读源代码并了解其功能。 但是，可能需要一些时间。 通过本系列文章，希望对您有所帮助。&lt;/p>&lt;h2 id="该系列的讲解方式">该系列的讲解方式&lt;/h2>&lt;p>我选择采取自上而下的方式。 在这一部分中，我们将探讨CPython虚拟机（VM）的核心概念。 接下来，我们将了解CPython如何将python源代码编译为VM可以执行的程序。 之后，我们将熟悉CPython源代码，并逐步执行一个程序，在此过程中研究解释器的主要部分。 最终，我们将能够逐一熟悉出语言的不同方面，并查看它们是如何实现的。 这绝不是一个严格的计划，而是我的大概想法。&lt;/p>&lt;p>Note: 在这篇文章中，我指的是CPython 3.9。 随着CPython的发展，某些实现细节肯定会发生变化。 我将尝试跟踪重要的更改并添加更新说明。&lt;/p>&lt;h2 id="概览">概览&lt;/h2>&lt;p>Python程序的执行大致包括三个阶段:&lt;/p>&lt;ol>&lt;li>初始化&lt;/li>&lt;li>编译&lt;/li>&lt;li>解释&lt;/li>&lt;/ol>&lt;p>在初始化阶段，CPython将初始化运行Python所需的数据结构。 它还准备诸如内置类型，配置和加载内置模块，设置导入系统等功能。 这是一个非常重要的阶段，由于其服务的性质，CPython的探索者经常忽略它。&lt;/p>&lt;p>接下来是编译阶段。 从不产生机器代码的意义上讲，CPython是解释器，而不是编译器。 但是，解释器通常在执行之前将源代码转换为某种中间表示。 CPython也是如此。 此翻译阶段执行的操作与典型编译器相同：解析源代码并构建AST（抽象语法树），从AST生成字节码，甚至执行一些字节码优化。&lt;/p>&lt;p>在进行下一阶段之前，我们需要了解什么是字节码。 字节码是一系列指令。 每条指令由两个字节组成：一个字节用于操作码，一个字节用于参数。 考虑一个例子：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(x): &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CPython将函数&lt;code>g()&lt;/code>的函数体转换为以下字节序列：[124，0，100，1，23，0，83，0]。 如果我们运行标准库&lt;code>dis&lt;/code>对其进行反汇编，则将获得以下信息：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ python -m dis example1.py...&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> LOAD_FAST &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>x&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">(&lt;/span>3&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> BINARY_ADD &lt;span style="color:#ae81ff">6&lt;/span> RETURN_VALUE&lt;/code>&lt;/pre>&lt;/div>&lt;p>LOAD_FAST操作码对应于字节124，参数为0。LOAD_CONST操作码对应于字节100，参数为1。BINARY_ADD和RETURN_VALUE指令始终分别编码为（23，0）和（83，0），因为他们不需要参数。&lt;/p>&lt;p>CPython的核心是执行字节码的虚拟机。 通过查看前面的示例，您可能会猜测它是如何工作的。 CPython的VM是基于堆栈的。 这意味着它使用堆栈执行指令来存储和检索数据。 LOAD_FAST指令将局部变量压入堆栈。 LOAD_CONST将一个常数压栈。 BINARY_ADD从堆栈中弹出两个对象，将它们加起来并将结果压回去。 最后，RETURN_VALUE弹出堆栈中的所有内容，并将结果返回给其调用方。&lt;/p>&lt;p>字节码在一个巨大的循环(evaluation loop)中执行，该循环在有指令时运行。 它将在产生值或产生错误时停止。&lt;/p>&lt;p>这样的简短概述会引发很多疑问：&lt;/p>&lt;ul>&lt;li>LOAD_FAST和LOAD_CONST操作码的参数是什么意思？ 他们是指数吗？ 他们索引什么？&lt;/li>&lt;li>VM是否在堆栈上放置值或对对象的引用？&lt;/li>&lt;li>CPython如何知道x是局部变量？&lt;/li>&lt;li>如果参数太大而无法容纳单个字节怎么办？&lt;/li>&lt;li>将两个数字相加的指令是否与连接两个字符串相同？ 如果是，那么VM如何区分这些操作？&lt;/li>&lt;/ul>&lt;p>为了回答这些以及其他有趣的问题，我们需要研究CPython VM的核心概念。&lt;/p>&lt;h2 id="代码对象函数对象帧对象">代码对象，函数对象，帧对象&lt;/h2>&lt;h3 id="代码对象">代码对象&lt;/h3>&lt;p>我们看到了一个简单函数的字节码的样子。 但是典型的Python程序更加复杂。 VM如何执行包含功能定义并进行功能调用的模块？&lt;/p>&lt;p>看下面的代码思考下:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(x): &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">print&lt;/span>(f(&lt;span style="color:#ae81ff">1&lt;/span>))&lt;/code>&lt;/pre>&lt;/div>&lt;p>它的字节码是什么样的？ 为了回答这个问题，让我们分析一下程序的功能。 它定义了函数&lt;code>f&lt;/code>()，以1作为参数调用&lt;code>f()&lt;/code>并输出调用结果。 无论函数&lt;code>f()&lt;/code>做什么，它都不是模块字节码的一部分。 我们可以通过运行反汇编程序来确认这一点。&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>python &lt;span style="color:#f92672">-&lt;/span>m dis example2&lt;span style="color:#f92672">.&lt;/span>py&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">0&lt;/span> (&lt;span style="color:#f92672">&amp;lt;&lt;/span>code object f at &lt;span style="color:#ae81ff">0x10bffd1e0&lt;/span>, file &lt;span style="color:#e6db74">&amp;#34;example.py&amp;#34;&lt;/span>, line &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>) &lt;span style="color:#ae81ff">2&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">1&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;f&amp;#39;&lt;/span>) &lt;span style="color:#ae81ff">4&lt;/span> MAKE_FUNCTION &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> STORE_NAME &lt;span style="color:#ae81ff">0&lt;/span> (f)&lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> LOAD_NAME &lt;span style="color:#ae81ff">1&lt;/span> (&lt;span style="color:#66d9ef">print&lt;/span>) &lt;span style="color:#ae81ff">10&lt;/span> LOAD_NAME &lt;span style="color:#ae81ff">0&lt;/span> (f) &lt;span style="color:#ae81ff">12&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">2&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#ae81ff">14&lt;/span> CALL_FUNCTION &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span> CALL_FUNCTION &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span> POP_TOP &lt;span style="color:#ae81ff">20&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">3&lt;/span> (None) &lt;span style="color:#ae81ff">22&lt;/span> RETURN_VALUE&lt;span style="color:#f92672">...&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在第1行上，我们通过从称为代码对象的对象制作函数并将其绑定到名称来定义函数&lt;code>f()&lt;/code>。 我们看不到函数&lt;code>f()&lt;/code>的字节码返回递增的参数。模块或函数体之类的单个可执行的代码段称为代码块， CPython将有关代码块功能的信息存储在称为代码对象的结构中， 它包含字节码以及该块内使用的变量名称列表之类的内容。 运行模块或调用函数意味着开始执行相应的代码对象。&lt;/p>&lt;h3 id="函数对象">函数对象&lt;/h3>&lt;p>但是，函数不仅是代码对象。 它必须包括其他信息，例如函数名称，文档字符串，默认参数以及在作用域内定义的变量的值。 此信息与代码对象一起存储在功能对象中。 MAKE_FUNCTION指令用于创建它。 在CPython源代码中对函数对象结构的定义前面带有以下注释：&lt;/p>&lt;blockquote>&lt;p>函数对象和代码对象不应相互混淆:&lt;/p>&lt;p>函数对象是通过执行&lt;code>def&lt;/code>语句创建的。他们在其&lt;code>__code__&lt;/code>属性中引用了一个代码对象，该对象是纯粹的语法对象，即仅是某些源代码行的编译版本。每个源代码“片段”有一个代码对象，但是每个代码对象可以被零个或多个函数对象引用，这取决于到目前为止，源代码中的“ def”语句执行了多少次。&lt;/p>&lt;/blockquote>&lt;p>几个函数对象如何引用一个代码对象？ 这是一个例子：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">make_add_x&lt;/span>(x): &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">add_x&lt;/span>(y): &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> y &lt;span style="color:#66d9ef">return&lt;/span> add_xadd_4 &lt;span style="color:#f92672">=&lt;/span> make_add_x(&lt;span style="color:#ae81ff">4&lt;/span>)add_5 &lt;span style="color:#f92672">=&lt;/span> make_add_x(&lt;span style="color:#ae81ff">5&lt;/span>)&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>make_add_x()&lt;/code>函数的字节码包含MAKE_FUNCTION指令。函数&lt;code>add_4()&lt;/code>和&lt;code>add_5()&lt;/code>是使用相同的代码对象调用此指令的结果。但是有一个不同的参数– x的值。每个函数都通过&lt;a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-5-how-variables-are-implemented-in-cpython/">cell variables&lt;/a>获得自己的功能，该机制使我们能够创建诸如&lt;code>add_4()&lt;/code>和&lt;code>add_5()&lt;/code>之类的闭包。&lt;/p>&lt;p>在讲述下一个概念之前, 让我们先来查看代码和函数对象的C定义，以更好地了解它们的含义。&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> PyCodeObject { PyObject_HEAD &lt;span style="color:#66d9ef">int&lt;/span> co_argcount; &lt;span style="color:#75715e">/* #arguments, except *args */&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> co_posonlyargcount; &lt;span style="color:#75715e">/* #positional only arguments */&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> co_kwonlyargcount; &lt;span style="color:#75715e">/* #keyword only arguments */&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> co_nlocals; &lt;span style="color:#75715e">/* #local variables */&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> co_stacksize; &lt;span style="color:#75715e">/* #entries needed for evaluation stack */&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> co_flags; &lt;span style="color:#75715e">/* CO_..., see below */&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> co_firstlineno; &lt;span style="color:#75715e">/* first source line number */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_code; &lt;span style="color:#75715e">/* instruction opcodes */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_consts; &lt;span style="color:#75715e">/* list (constants used) */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_names; &lt;span style="color:#75715e">/* list of strings (names used) */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_varnames; &lt;span style="color:#75715e">/* tuple of strings (local variable names) */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_freevars; &lt;span style="color:#75715e">/* tuple of strings (free variable names) */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_cellvars; &lt;span style="color:#75715e">/* tuple of strings (cell variable names) */&lt;/span> Py_ssize_t &lt;span style="color:#f92672">*&lt;/span>co_cell2arg; &lt;span style="color:#75715e">/* Maps cell vars which are arguments. */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_filename; &lt;span style="color:#75715e">/* unicode (where it was loaded from) */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_name; &lt;span style="color:#75715e">/* unicode (name, for reference) */&lt;/span> &lt;span style="color:#75715e">/* ... more members ... */&lt;/span>};&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> { PyObject_HEAD PyObject &lt;span style="color:#f92672">*&lt;/span>func_code; &lt;span style="color:#75715e">/* A code object, the __code__ attribute */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_globals; &lt;span style="color:#75715e">/* A dictionary (other mappings won&amp;#39;t do) */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_defaults; &lt;span style="color:#75715e">/* NULL or a tuple */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_kwdefaults; &lt;span style="color:#75715e">/* NULL or a dict */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_closure; &lt;span style="color:#75715e">/* NULL or a tuple of cell objects */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_doc; &lt;span style="color:#75715e">/* The __doc__ attribute, can be anything */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_name; &lt;span style="color:#75715e">/* The __name__ attribute, a string object */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_dict; &lt;span style="color:#75715e">/* The __dict__ attribute, a dict or NULL */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_weakreflist; &lt;span style="color:#75715e">/* List of weak references */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_module; &lt;span style="color:#75715e">/* The __module__ attribute, can be anything */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_annotations; &lt;span style="color:#75715e">/* Annotations, a dict or NULL */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_qualname; &lt;span style="color:#75715e">/* The qualified name */&lt;/span> vectorcallfunc vectorcall;} PyFunctionObject;&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="帧对象">帧对象&lt;/h3>&lt;p>VM执行代码对象时，必须跟踪变量的值和不断变化值的堆栈。它还需要记住在哪里停止执行当前代码对象以执行另一个代码对象，以及在哪里返回。 CPython将此信息存储在帧对象或简单的帧中。 帧提供了代码对象可以执行需要的状态。 为了让我们对CPython源代码会越来越熟悉，我在这里也保留了帧的定义：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> _frame { PyObject_VAR_HEAD &lt;span style="color:#66d9ef">struct&lt;/span> _frame &lt;span style="color:#f92672">*&lt;/span>f_back; &lt;span style="color:#75715e">/* previous frame, or NULL */&lt;/span> PyCodeObject &lt;span style="color:#f92672">*&lt;/span>f_code; &lt;span style="color:#75715e">/* code segment */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_builtins; &lt;span style="color:#75715e">/* builtin symbol table (PyDictObject) */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_globals; &lt;span style="color:#75715e">/* global symbol table (PyDictObject) */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_locals; &lt;span style="color:#75715e">/* local symbol table (any mapping) */&lt;/span> PyObject &lt;span style="color:#f92672">**&lt;/span>f_valuestack; &lt;span style="color:#75715e">/* points after the last local */&lt;/span> PyObject &lt;span style="color:#f92672">**&lt;/span>f_stacktop; &lt;span style="color:#75715e">/* Next free slot in f_valuestack. ... */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_trace; &lt;span style="color:#75715e">/* Trace function */&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> f_trace_lines; &lt;span style="color:#75715e">/* Emit per-line trace events? */&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> f_trace_opcodes; &lt;span style="color:#75715e">/* Emit per-opcode trace events? */&lt;/span> &lt;span style="color:#75715e">/* Borrowed reference to a generator, or NULL */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_gen; &lt;span style="color:#66d9ef">int&lt;/span> f_lasti; &lt;span style="color:#75715e">/* Last instruction if called */&lt;/span> &lt;span style="color:#75715e">/* ... */&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> f_lineno; &lt;span style="color:#75715e">/* Current line number */&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> f_iblock; &lt;span style="color:#75715e">/* index in f_blockstack */&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> f_executing; &lt;span style="color:#75715e">/* whether the frame is still executing */&lt;/span> PyTryBlock f_blockstack[CO_MAXBLOCKS]; &lt;span style="color:#75715e">/* for try and loop blocks */&lt;/span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_localsplus[&lt;span style="color:#ae81ff">1&lt;/span>]; &lt;span style="color:#75715e">/* locals+stack, dynamically sized */&lt;/span>};&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一个帧在执行模块的代码对象时创建。 每当需要执行另一个代码对象，CPython都会创建一个新帧。 每个帧都有对前一帧的引用。 因此，帧形成帧的栈，也称为调用栈，当前帧位于顶部。 调用函数时，会将新的帧压入栈。 从当前执行的帧返回时，CPython通过记住其最后处理的指令来继续执行前一帧。 从某种意义上来说，CPython VM除了构造和执行帧外什么也不做。 但是，正如我们将很快看到的那样，这个描述，简单来说说，隐藏了一些细节。&lt;/p>&lt;h3 id="线程-解释器-运行时">线程, 解释器, 运行时&lt;/h3>&lt;p>我们已经研究了三个重要概念：&lt;/p>&lt;ul>&lt;li>代码对象&lt;/li>&lt;li>函数对象&lt;/li>&lt;li>帧对象&lt;/li>&lt;/ul>&lt;p>CPython还有三个别的:&lt;/p>&lt;ul>&lt;li>线程状态&lt;/li>&lt;li>解释器状态&lt;/li>&lt;li>运行时状态&lt;/li>&lt;/ul>&lt;h4 id="线程状态">线程状态&lt;/h4>&lt;p>线程状态是一种数据结构，其中包含了线程特有的数据，包括调用堆栈，异常状态和调试设置。&lt;/p>&lt;p>不应将其与操作系统的线程混淆。但是它们有非常紧密的关系，考虑使用标准库 &lt;a href="https://docs.python.org/3/library/threading.html">&lt;code>treading&lt;/code>&lt;/a> 模块在单独的线程里运行函数会发生什么:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">from&lt;/span> threading &lt;span style="color:#f92672">import&lt;/span> Thread&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(): &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;Perform an I/O-bound task&amp;#34;&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">pass&lt;/span>t &lt;span style="color:#f92672">=&lt;/span> Thread(target&lt;span style="color:#f92672">=&lt;/span>f)t&lt;span style="color:#f92672">.&lt;/span>start()t&lt;span style="color:#f92672">.&lt;/span>join()&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>t.start()&lt;/code> 实际上通过调用操作系统的函数(Unix/Linux系统上是&lt;code>pthread_create()&lt;/code>，Windnows上是&lt;code>_beginthreadex()&lt;/code> )创建了一个新的系统线程. 新创建的线程从&lt;code>_thread&lt;/code>模块中调用负责调用目标的函数.&lt;/p>&lt;p>新创建的线程通过&lt;code>_thread&lt;/code>模块中的函数调用该目标函数。该函数不仅接收目标函数和目标函数的参数，还接收要在新操作系统线程中使用的新线程状态。新操作系统进程将执行循环放入自己的线程状态里， 因此始终可以使用它。&lt;/p>&lt;p>我们可能还记得著名的GIL（全局解释器锁) 它防止多个线程同时进入执行循环。这样做的主要原因是在不引入更多细粒度的锁的情况下保护CPython的状态免受损坏。 &lt;a href="https://docs.python.org/3.9/c-api/index.html">Python/C API 指南&lt;/a> 清楚的解释了GIL:&lt;/p>&lt;blockquote>&lt;p>&lt;em>Python解释器不是完全线程安全的。Python解释器不是完全线程安全的。 为了支持多线程Python程序，有一个全局锁，称为全局解释器锁或GIL，必须由当前线程持有，然后才能安全地访问Python对象。 如果没有锁，即使是最简单的操作也可能在多线程程序中引起问题：例如，当两个线程同时增加同一对象的引用计数时，引用计数最终只能被增加一次，而不是两次。&lt;/em>&lt;/p>&lt;/blockquote>&lt;p>要管理多个线程，需要有一个比线程状态更高级别的数据结构。&lt;/p>&lt;h4 id="解释器和运行时状态">解释器和运行时状态&lt;/h4>&lt;p>实际上，上面说的更高级的数据结构有两个：解释器状态和运行时状态。 两者的差别似乎并不十分明显。&lt;/p>&lt;p>解释器状态是一组线程以及该组特定的数据. 线程共享诸如加载的模块(&lt;code>sys.modules&lt;/code>), 内置模块(&lt;code>builtins.__dict__&lt;/code>)以及导入系统之类的东西 (&lt;code>importlib&lt;/code>)。&lt;/p>&lt;p>运行时状态是全局变量。它存储特定进程的数据。 其中包括CPython的状态（例如，是否已初始化？）和GIL机制。&lt;/p>&lt;p>通常，一个进程的所有线程都属于同一个解释器。 但是，在少数情况下，可能需要创建一个子解释器来隔离一组线程。一个例子是 &lt;a href="https://modwsgi.readthedocs.io/en/develop/user-guides/processes-and-threading.html#python-sub-interpreters">mod_wsgi&lt;/a> ，它使用不同的解释器来运行WSGI应用程序。隔离的最明显效果是每组线程都有自己的所有模块版本，包括&lt;code>__main__&lt;/code>，这是一个全局命名空间。&lt;/p>&lt;p>CPython没有提供类似于&lt;code>threading&lt;/code>模块的简便方法来创建新的解释器。目前仅通过Python/C API提供支持, &lt;a href="https://www.python.org/dev/peps/pep-0554/">但有一天可能会更改&lt;/a> 。&lt;/p>&lt;h3 id="架构摘要">架构摘要&lt;/h3>&lt;p>让我们快速总结一下CPython的体系结构，看看一切如何融合在一起。解释器可以看作是分层结构。 以下总结了这些层是什么:&lt;/p>&lt;ol>&lt;li>运行时: 进程的整体状态；这包括GIL和内存分配机制&lt;/li>&lt;li>解释器: 一组线程和它们共享的一些数据，例如导入的模块。&lt;/li>&lt;li>线程：包含特定数据的操作系统线程； 包括调用堆栈。&lt;/li>&lt;li>帧：调用堆栈的元素； 帧包含一个代码对象，并提供执行它的状态。&lt;/li>&lt;li>执行循环：执行帧对象的地方。&lt;/li>&lt;/ol>&lt;p>这些层由我们已经看到的相应数据结构表示。 在某些情况下，它们并不等价。 例如，使用全局变量来实现内存分配机制。 它不是运行时状态的一部分，但肯定是运行时层的一部分。&lt;/p>&lt;h3 id="结论">结论&lt;/h3>&lt;p>在这一部分中，我们概述了&lt;code>python&lt;/code> 命令为执行Python程序所做的工作。 我们已经看到它在三个阶段起作用:&lt;/p>&lt;ol>&lt;li>初始化CPython&lt;/li>&lt;li>将源代码编译为模块的代码对象； 和&lt;/li>&lt;li>执行代码对象的字节码。&lt;/li>&lt;/ol>&lt;p>解释器中负责字节码执行的部分称为虚拟机。 CPython VM具有几个特别重要的概念：代码对象，帧对象，线程状态，解释器状态和运行时。 这些数据结构构成了CPython体系结构的核心。&lt;/p>&lt;p>我们没有涉及很多东西。 我们避免深入研究源代码。 初始化和编译阶段完全超出了我们的范围。 相反，我们从虚拟机的概述开始。 我认为，通过这种方式，我们可以更好地了解每个阶段的职责。 现在，我们知道了CPython将源代码编译到的代码对象。&lt;/p>&lt;p>&lt;a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-2-how-the-cpython-compiler-works/">下一篇&lt;/a>，我们将看到它是如何做到的。&lt;/p></description></item><item><title>golang里被中括号坑的记录</title><link>https://laujay.com/posts/go-regexp/</link><pubDate>Sun, 06 Dec 2020 18:00:59 +0800</pubDate><guid>https://laujay.com/posts/go-regexp/</guid><description>&lt;p>今天众多大佬要用rss订阅本博客。。深感荣幸。。但是出现生成rss文件有错那就尴尬了。&lt;/p>&lt;p>于是到了茶馆打开电脑就开始修。定位了一会就定位到是特殊字符的问题。搜了下查到hugo模版里的replaceRE函数，于是就开始撸正则表达式。结果。。&lt;/p>&lt;h2 id="hugo-replacere-函数好难咱不会用">hugo replaceRE 函数好难咱不会用&lt;/h2>&lt;p>hugo的replaceRE文档有这句话：&lt;/p>&lt;blockquote>&lt;p>Hugo uses Go’s &lt;a href="https://golang.org/pkg/regexp/">Regular Expression package&lt;/a>,which is the same general syntax used by Perl, Python, and other languages but with a few minor differences for those coming from a background in PCRE.&lt;/p>&lt;/blockquote>&lt;p>于是咱就用上了浅薄的正则知识开始撸。很快就撸了一段。。确实也不报错了。于是很开心的提了个pr给用的hugo theme。回头自己看，哎生成的rss里描述的内容咋全是刚换的。知道自己刚写的正则有问题。于是各种尝试。最终的结果都是不起作用。&lt;/p>&lt;h2 id="regexp用的正则语法有问题不是眼神有问题">regexp用的正则语法有问题？不，是眼神有问题&lt;/h2>&lt;p>期间各种尝试。。反正时间很快就没了， 眼瞅着从午饭搞到晚饭了。反正都是不work。&lt;/p>&lt;p>心塞之余还是先去喝茶吧。。果然解决问题如果出现瓶颈就应该放松下。&lt;/p>&lt;p>喝完几泡茶，回到座位，看regexp的文档看到他的语法&lt;a href="https://github.com/google/re2/wiki/Syntax">来源&lt;/a>。&lt;/p>&lt;p>点击去看。。看到&lt;code>[[:cntrl:]] | control (≡ [\x00-\x1F\x7F])&lt;/code>我突然灵机一动把原始的正则给复制过去。居然工作了。比对了下。。才发现人家有俩中括号。。坑死了。&lt;/p></description></item><item><title>2020我做了什么</title><link>https://laujay.com/posts/2020/</link><pubDate>Sat, 05 Dec 2020 21:19:30 +0800</pubDate><guid>https://laujay.com/posts/2020/</guid><description>&lt;blockquote>&lt;p>年结。。233已经不想往上加时间了，于是选择年结。。希望不要烂尾&lt;/p>&lt;/blockquote>&lt;h2 id="开源">开源&lt;/h2>&lt;p>没啥正经的开源项目要忙。。。疫情期间搞了下博客生成器， 换成hugo了。&lt;/p>&lt;p>为此我2020年第一个pr居然是给一个hugo的theme，嗯就是我现在在用的&lt;a href="https://github.com/funkydan2/hugo-kiera">这个&lt;/a>&lt;/p>&lt;p>博客水了几篇文章，技术相关的都是以前的盲区。就是很熟悉但是每次都是糊弄&lt;/p>&lt;p>过去能跑就行，没认真地去研究下， 这是个坏毛病得改。&lt;/p>&lt;h2 id="旅游">旅游&lt;/h2>&lt;p>木有。。。&lt;/p>&lt;h2 id="技能">技能&lt;/h2>&lt;p>由于疫情的问题，导致厨艺大为长进。。已经从熟了进化为能吃，偶尔还能出暴击居然还挺好吃。&lt;/p>&lt;p>最擅长炖肉。。。反正料够都是好吃的。&lt;/p>&lt;p>技术上学了好多有的没的，反正就是随心所欲的学呗。。虽然是低效，但是玩的很开心。。just for fun。当然。。要改。。毕竟生活不止有诗和远方。。还有眼前的苟且。&lt;/p>&lt;h2 id="生活">生活&lt;/h2>&lt;p>最大的变化就是养了只狗子， 名字叫酸奶。。就是这个小子:&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/yogurt.jpeg" alt="yogurt">&lt;/p>&lt;p>这是他小时候，别人帮我喂他的时候拍的，算是他颜值的巅峰吧。&lt;/p>&lt;p>现在已经是一个胖子了&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/yogurt2.jpeg" alt="yogurt2">&lt;/p>&lt;p>然后就是找了私人教开始买课锻炼身体（目的是为了监督我自己）。。疫情期间发生了两次颈椎不适导致的头疼，再不锻炼感觉就要挂了。&lt;/p>&lt;p>附近新开了家茶馆。。非常近，已经是最近固定去处了。&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/guangyunhao.jpeg" alt="广云号">&lt;/p>&lt;h2 id="最后">最后&lt;/h2>&lt;blockquote>&lt;p>初闻不识曲中意， 再闻已是曲中人。&lt;/p>&lt;/blockquote>&lt;p>参加了次发小的婚礼，所见所闻，大多数人都活成了别人想要的样子。&lt;/p>&lt;p>anyway， 开心最重要，不是么。&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/fighting.jpeg" alt="加油">&lt;/p></description></item><item><title>Docker Network External</title><link>https://laujay.com/posts/docker-network-external/</link><pubDate>Thu, 27 Aug 2020 10:41:30 +0800</pubDate><guid>https://laujay.com/posts/docker-network-external/</guid><description>&lt;blockquote>&lt;p>在使用docker的过程中，自建开发环境使用docker-compose是非常正常的需求，正常情况下多个容器都是通过一个docker-compose.yml唤起的，并且可以通过services名直接连接而不需要知道依赖的容器的ip地址。然而，如果遇到容器并非定义在同一个yml中的时候，连接容器就会比较麻烦。我见过直接获取对方容器ip来使用的，但是每次都得获取容器ip地址。&lt;/p>&lt;/blockquote>&lt;p>&lt;a href="https://stackoverflow.com/questions/39067295/docker-compose-external-container">参考自&lt;/a>&lt;/p>&lt;p>在不使用docker-compose的时候可以使用&amp;ndash;link参数如下：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">docker run --rm --name rds -d redis &lt;span style="color:#75715e"># 启动redis&lt;/span>docker run --rm --name app --link rds -d task &lt;span style="color:#75715e"># 启动一个应用并连接到rds&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果使用docker-compose就简单了:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>&lt;span style="color:#f92672">services&lt;/span>: &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#f92672">images&lt;/span>: &lt;span style="color:#ae81ff">task&lt;/span> &lt;span style="color:#f92672">depends_on&lt;/span>: - &lt;span style="color:#ae81ff">reds&lt;/span> &lt;span style="color:#f92672">res&lt;/span>: &lt;span style="color:#f92672">images&lt;/span>: &lt;span style="color:#ae81ff">redis&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在要解决不是一个docker-compose.yml或者是与docker run起来的容器链接的问题。&lt;/p>&lt;p>有几种解决方案，我只推荐使用以下这种方式：&lt;/p>&lt;p>首先是： app.yml&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>&lt;span style="color:#f92672">services&lt;/span>: &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#f92672">images&lt;/span>: &lt;span style="color:#ae81ff">task&lt;/span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">app&lt;/span> &lt;span style="color:#f92672">networks&lt;/span>: - &lt;span style="color:#ae81ff">app_net&lt;/span> &lt;span style="color:#f92672">networks&lt;/span>: &lt;span style="color:#f92672">app_net&lt;/span>: &lt;span style="color:#f92672">external&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着是: rds.yml&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>&lt;span style="color:#f92672">services&lt;/span>: &lt;span style="color:#f92672">rds&lt;/span>: &lt;span style="color:#f92672">images&lt;/span>: &lt;span style="color:#ae81ff">redis&lt;/span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">rds&lt;/span> &lt;span style="color:#f92672">networks&lt;/span>: - &lt;span style="color:#ae81ff">app_net&lt;/span> &lt;span style="color:#f92672">networks&lt;/span>: &lt;span style="color:#f92672">app_net&lt;/span>: &lt;span style="color:#f92672">external&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用的时候:&lt;/p>&lt;p>deploy.sh :&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#75715e">#!/bin/bash&lt;/span>&lt;span style="color:#75715e">&lt;/span>docker network create app_netdocker-compose -f ./deploy/rds.yml up -dsleep &lt;span style="color:#ae81ff">1&lt;/span>docker-compose -f ./deploy/app.yml up -d&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着可以测试下:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">docker exec -it app ping rds&lt;/code>&lt;/pre>&lt;/div>&lt;p>正常情况下会得到ping的结果，是通的。&lt;/p>&lt;p>如果这时候有一个已经存在的容器db，要使用的话可以:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">docker network connect app_net db&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样三个容器都可以互通了。&lt;/p></description></item><item><title>MQ-RabbitMQ</title><link>https://laujay.com/posts/mq-rabbitmq/</link><pubDate>Wed, 27 May 2020 09:04:57 +0800</pubDate><guid>https://laujay.com/posts/mq-rabbitmq/</guid><description>&lt;p>从一个简单的例子开始。&lt;/p>&lt;p>首先是生产者&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> sys&lt;span style="color:#f92672">import&lt;/span> pikacredentials &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>PlainCredentials(&lt;span style="color:#e6db74">&amp;#34;guest&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;guest&amp;#34;&lt;/span>)conn_params &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>ConnectionsParameters(&lt;span style="color:#e6db74">&amp;#34;localhost&amp;#34;&lt;/span>, credentials&lt;span style="color:#f92672">=&lt;/span> credentials)conn_broker &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>BlockingConnection(conn_params) &lt;span style="color:#75715e"># 到此为止,建立了到代理服务器的链接&lt;/span>channel &lt;span style="color:#f92672">=&lt;/span> conn_broker&lt;span style="color:#f92672">.&lt;/span>channel() &lt;span style="color:#75715e"># 获取信道&lt;/span>channel&lt;span style="color:#f92672">.&lt;/span>exchange_declare(exchange&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-exchange&amp;#34;&lt;/span>, type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;direct&amp;#34;&lt;/span>, passive&lt;span style="color:#f92672">=&lt;/span>False, durable&lt;span style="color:#f92672">=&lt;/span>True, auto_delete&lt;span style="color:#f92672">=&lt;/span>False) &lt;span style="color:#75715e"># 声明交换器&lt;/span>msg &lt;span style="color:#f92672">=&lt;/span> sys&lt;span style="color:#f92672">.&lt;/span>argv[&lt;span style="color:#ae81ff">1&lt;/span>]msg_props &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>BasicProperties()msg_props&lt;span style="color:#f92672">.&lt;/span>content_type&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">“&lt;/span>text&lt;span style="color:#f92672">/&lt;/span>plain&lt;span style="color:#e6db74">&amp;#34;. # 创建纯文本消息&lt;/span>channel&lt;span style="color:#f92672">.&lt;/span>basic_publish(body&lt;span style="color:#f92672">=&lt;/span>msg, exchange&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-exchange&amp;#34;&lt;/span>, properties&lt;span style="color:#f92672">=&lt;/span>msg_props, routing_key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hola&amp;#34;&lt;/span>) &lt;span style="color:#75715e"># 发布消息&lt;/span>conn_broker&lt;span style="color:#f92672">.&lt;/span>close()&lt;/code>&lt;/pre>&lt;/div>&lt;p>消费者:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> sys&lt;span style="color:#f92672">import&lt;/span> pikacredentials &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>PlainCredentials(&lt;span style="color:#e6db74">&amp;#34;guest&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;guest&amp;#34;&lt;/span>)conn_params &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>ConnectionsParameters(&lt;span style="color:#e6db74">&amp;#34;localhost&amp;#34;&lt;/span>, credentials&lt;span style="color:#f92672">=&lt;/span> credentials)conn_broker &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>BlockingConnection(conn_params) &lt;span style="color:#75715e"># 到此为止,建立了到代理服务器的链接&lt;/span>channel &lt;span style="color:#f92672">=&lt;/span> conn_broker&lt;span style="color:#f92672">.&lt;/span>channel() &lt;span style="color:#75715e"># 获取信道&lt;/span>channel&lt;span style="color:#f92672">.&lt;/span>exchange_declare(exchange&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-exchange&amp;#34;&lt;/span>, type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;direct&amp;#34;&lt;/span>, passive&lt;span style="color:#f92672">=&lt;/span>False, durable&lt;span style="color:#f92672">=&lt;/span>True, auto_delete&lt;span style="color:#f92672">=&lt;/span>False) &lt;span style="color:#75715e"># 声明交换器&lt;/span>channel&lt;span style="color:#f92672">.&lt;/span>queue_declare(queue&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-queue&amp;#34;&lt;/span>) &lt;span style="color:#75715e"># 声明队列&lt;/span>channel&lt;span style="color:#f92672">.&lt;/span>queue_bind(queue&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-queue&amp;#34;&lt;/span>, exchange&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-exchange&amp;#34;&lt;/span>, routing_key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hola&amp;#34;&lt;/span>) &lt;span style="color:#75715e"># 通过routing_key将队列和交换器绑定起来&lt;/span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">msg_consumer&lt;/span>(channel, method, header, body): channel&lt;span style="color:#f92672">.&lt;/span>basic_ack(delivery_tag&lt;span style="color:#f92672">=&lt;/span>method&lt;span style="color:#f92672">.&lt;/span>delivery_tag) &lt;span style="color:#66d9ef">if&lt;/span> body&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#34;utf8&amp;#34;&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;quit&amp;#34;&lt;/span>: &lt;span style="color:#75715e"># 例子来源于rabbitmq实战,但是body在 python3中是byte类型&lt;/span> channel&lt;span style="color:#f92672">.&lt;/span>basic_cancel(consumer_tag&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-consumer&amp;#34;&lt;/span>) channel&lt;span style="color:#f92672">.&lt;/span>stop_consuming() &lt;span style="color:#66d9ef">else&lt;/span>: &lt;span style="color:#66d9ef">print&lt;/span>(body&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#34;utf8&amp;#34;&lt;/span>))channel&lt;span style="color:#f92672">.&lt;/span>basic_consume(queue&lt;span style="color:#f92672">=&lt;/span>queue_name, on_message_callback&lt;span style="color:#f92672">=&lt;/span> msg_consumer, auto_ack&lt;span style="color:#f92672">=&lt;/span>False)channel&lt;span style="color:#f92672">.&lt;/span>start_consuming()&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="生产者和消费者">生产者和消费者&lt;/h2>&lt;p>生产者创建消息=》发布到代理服务器(RabbitMQ)&lt;/p>&lt;h3 id="消息">消息&lt;/h3>&lt;p>消息分为: payload和label&lt;/p>&lt;p>payload是你要传输的内容,label描述了有效载荷.&lt;/p>&lt;p>AMQP用标签表述消息, rabbitmq根据标签把消息发送给感兴趣的接受放. 其方式是fire-and-forget&lt;/p>&lt;p>接受者得到payload, 标签在过程中不会发送&lt;/p>&lt;h3 id="持久化消息">持久化消息&lt;/h3>&lt;p>delivery mode 设置为2, 但是必须是持久化的交换器和持久化的队列, 三者加在一起才能真正具有持久化.&lt;/p>&lt;h3 id="信道channel">信道(channel)&lt;/h3>&lt;p>信道事建立在“真实” TCP链接内的虚拟链接, 信道复用TCP链接,可以有无数个信道,但是会共用一个TCP链接.&lt;/p>&lt;h2 id="amqp三要素">AMQP三要素&lt;/h2>&lt;h3 id="交换器exchange">交换器(exchange)&lt;/h3>&lt;p>生产者把消息发布到交换器上&lt;/p>&lt;p>交换器根据routing-key来决定消息投递到哪个队列&lt;/p>&lt;p>队列通过routing-key绑定到交换器.&lt;/p>&lt;p>交换器类型: topic, fanout, direct, headers&lt;/p>&lt;p>direct: 如果路由键匹配,就投递到对应的队列&lt;/p>&lt;p>fanout: 广播到所有绑定到该交换器的队列上&lt;/p>&lt;p>topic: 多个来源的消息到同一个队列上&lt;/p>&lt;h3 id="持久化">持久化&lt;/h3>&lt;p>durable设置为True&lt;/p>&lt;h3 id="队列queue">队列(queue)&lt;/h3>&lt;p>消息到达队列,并被消费者接受&lt;/p>&lt;h3 id="创建队列">创建队列&lt;/h3>&lt;p>queue.declare, 如果消费者在一条信道上订阅了某个队列,无法再声明队列了, 必须先取消订阅, 将 信道设置为“传输模式”.&lt;/p>&lt;p>queue.declare有两个参数:&lt;/p>&lt;ul>&lt;li>&lt;p>exclusive, 为true, 队列私有, 只能创建的使用,一个队列一个消费者&lt;/p>&lt;/li>&lt;li>&lt;p>auto-delete , 最后一个消费者取消订阅后, 队列自动移除.&lt;/p>&lt;/li>&lt;/ul>&lt;p>交换器是topic情况下:queue.bind_queue通过指定队列名, 交换器名, 和绑定键名, 将队列绑定到交换器.&lt;/p>&lt;h3 id="持久化-1">持久化&lt;/h3>&lt;p>durable设置为True&lt;/p>&lt;h3 id="绑定bind_key">绑定(bind_key)&lt;/h3>&lt;p>绑定key决定了交换器将符合绑定key规则的消息都发送到这个队列里.&lt;/p>&lt;h2 id="vhost虚拟主机">vhost虚拟主机&lt;/h2>&lt;p>虚拟主机实现了自身的交换器,队列,和绑定, 并且带有权限控制&lt;/p>&lt;p>vhost只能通过命令行来创建删除&lt;/p>&lt;h3 id="创建">创建&lt;/h3>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#75715e"># rabbitmqctl add_vhost[vhost_name]&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除">删除&lt;/h3>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#75715e"># rabbitmqctl delete_vhost[vhost_name]&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="显示">显示&lt;/h3>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#75715e"># rabbitmqctl list_vhosts&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="多个消费者订阅到同一队列如何分发消息">多个消费者订阅到同一队列,如何分发消息&lt;/h2>&lt;p>rabbitmq拥有多个消费者的时候, 队列收到的消息将以(round-robin)的方式发送给消费者, 每个消息只会发送给一个消费者.&lt;/p>&lt;h2 id="ack机制">ACK机制&lt;/h2>&lt;p>消费者确认消息会basic.ack显式发送确认.或者auto-ack为true. 如果没有ack,链接断开,那么该消息会被发给下一个 消费者, 确保消息被正确处理.&lt;/p>&lt;p>如果没有返回ack,那么rabbitmq不会发送下一条消息给消费者.&lt;/p>&lt;h2 id="reject机制">Reject机制&lt;/h2>&lt;p>如果消费者容易出问题,但是消息又不想删除, 两种做法,第一断开链接,第二 basic.reject(版本大于2.0).&lt;/p>&lt;p>如果reject设置了requeue参数为true, 该消息会被发给下一个消费者.&lt;/p></description></item><item><title>The Python Packaging</title><link>https://laujay.com/posts/the-python-packaging/</link><pubDate>Thu, 14 May 2020 08:39:47 +0800</pubDate><guid>https://laujay.com/posts/the-python-packaging/</guid><description>&lt;h2 id="名字">名字&lt;/h2>&lt;p>Python的模块或者包名应该遵循下面几条:&lt;/p>&lt;ul>&lt;li>总是小写&lt;/li>&lt;li>pypi上唯一&lt;/li>&lt;li>不要用中划线分隔，下划线或者干脆不要分隔单词&lt;/li>&lt;/ul>&lt;h2 id="最小结构">最小结构&lt;/h2>&lt;pre>&lt;code>jay_hello/ jay_hello/ __init__.py setup.py&lt;/code>&lt;/pre>&lt;p>假设，&lt;code>__init__.py&lt;/code>文件里就一个hello_world&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">hello_world&lt;/span>(): &lt;span style="color:#66d9ef">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello world!&amp;#34;&lt;/span>)&lt;/code>&lt;/pre>&lt;/div>&lt;p>setup.py文件里应该是以下内容:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">from&lt;/span> setuptools &lt;span style="color:#f92672">import&lt;/span> setupsetup(name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;jay_hello&amp;#34;&lt;/span>, version&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;0.0.1&amp;#34;&lt;/span>, description&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;just say hello&amp;#34;&lt;/span>, url&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;https://github.com/lau-jay/jay_hello&amp;#34;&lt;/span>, author&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Lau Jay&amp;#34;&lt;/span>, author_email&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;example@gamil.com&amp;#34;&lt;/span>, license&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;MIT&amp;#39;&lt;/span>, packages&lt;span style="color:#f92672">=&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;jay_hello&amp;#34;&lt;/span>], zip_safe&lt;span style="color:#f92672">=&lt;/span>False)&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在可以通过下面这种方式安装&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">pip install . &lt;/code>&lt;/pre>&lt;/div>&lt;p>本地开发时建议使用下面这种，原因是其使用了软链接，你对代码文件的任何更改不再需要任何操作被使用&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">pip install -e .&lt;/code>&lt;/pre>&lt;/div>&lt;p>packaging.python.org上的原文是: &lt;code>in such a way that the project appears to be installed, but yet is still editable from the src tree&lt;/code>&lt;/p>&lt;p>那么现在就可以在repl里导入使用了&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">python setup.py develop &lt;/code>&lt;/pre>&lt;/div>&lt;p>这个是&lt;code>pip install -e .&lt;/code>底层实际执行的方法，会在&lt;code>site-packages&lt;/code>里创建&lt;code>.egg-link&lt;/code> 文件去链接源码目录&lt;/p>&lt;h2 id="pypi上发布">PyPI上发布&lt;/h2>&lt;h3 id="注册账户">注册账户&lt;/h3>&lt;p>略&lt;/p>&lt;h3 id="注册名字上传元数据以及创建包页面创建分发包并上传">注册名字，上传元数据以及创建包页面，创建分发包并上传&lt;/h3>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">python setup.py register sdist upload&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安装包">安装包&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">pip install jay_hello&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="setuppy">setup.py&lt;/h2>&lt;p>setup参数解析&lt;/p>&lt;h3 id="依赖">依赖&lt;/h3>&lt;p>&lt;code>install_requires&lt;/code>类型是字符串或者字符串列表，&lt;/p>&lt;p>ps: 19.0版本开始pip移除了对 &lt;code>dependency_links&lt;/code> 的支持&lt;/p>&lt;h3 id="提供命令行">提供命令行&lt;/h3>&lt;p>&lt;code>entry_points&lt;/code>：这个参数允许Python函数直接注册为命令行工具，这个机制非常可以方便地提供程序的命令行工具&lt;/p>&lt;pre>&lt;code class="language-ptyhon" data-lang="ptyhon">setup( ... entry_points = { &amp;quot;console_scripts&amp;quot;: [&amp;quot;jayhello= jay_hello:hello_world&amp;quot;], })&lt;/code>&lt;/pre>&lt;p>&lt;code>scripts&lt;/code> : 安装包的时候，setuptools会拷贝脚本到PATH，可以像Linux命令那样使用，这个字段指定的脚本不需要是Python脚本，任何可执行的都行, 假设增加了一个bin目录，并增加一个shell脚本&lt;/p>&lt;pre>&lt;code>setup( ... scripts=[&amp;quot;/bin/run.sh&amp;quot;])&lt;/code>&lt;/pre>&lt;h3 id="添加非代码文件">添加非代码文件&lt;/h3>&lt;p>如果是图像，数据表，文档等。为了让setuptools正确处理他们&lt;/p>&lt;p>需要添加个MANIFEST.in文件，例如：&lt;/p>&lt;pre>&lt;code>include README.mdinclude docs/*.md&lt;/code>&lt;/pre>&lt;p>为了启用这些，需要如下设置参数:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">setup( &lt;span style="color:#f92672">...&lt;/span> include_package_data&lt;span style="color:#f92672">=&lt;/span>True)&lt;/code>&lt;/pre>&lt;/div>&lt;p>更多参数请参见&lt;a href="setuptools.readthedocs.io/en/latest/setuptools.html">stuptools文档&lt;/a>&lt;/p></description></item><item><title>The Pytest Discovery</title><link>https://laujay.com/posts/the-pytest-path/</link><pubDate>Fri, 08 May 2020 07:38:45 +0800</pubDate><guid>https://laujay.com/posts/the-pytest-path/</guid><description>&lt;blockquote>&lt;p>对于pytest，我一直是使用，看文档也是只看fixture那部分的。昨天跟公司的vp争论一个问题，vp觉得tests目录下不该有 &lt;code>__init__.py&lt;/code>文件，这样子对于unite test来说语义是不对的。要使用&lt;code>setup.py develop&lt;/code>将包装载后测试，这样就不会出现我引入&lt;code>__init__.py&lt;/code>的初衷，为了找到找不到要测试的包。&lt;/p>&lt;/blockquote>&lt;p>首先，我没有认真研究为啥找不到包，但是加了&lt;code>__init__.py&lt;/code>在tests目录就能够正常pytest命令跑完测试。也就是说我是不知道原因的情况下，误打误撞利用的pytest的机制。&lt;/p>&lt;p>为了搞清这个问题我认真阅读了&lt;a href="https://docs.pytest.org/en/latest/goodpractices.html#tests-outside-application-code">该章&lt;/a> 发现了如下的文字:&lt;/p>&lt;blockquote>&lt;pre>&lt;code>setup.pymypkg/ ...tests/ __init__.py foo/ __init__.py test_view.py bar/ __init__.py test_view.py&lt;/code>&lt;/pre>&lt;p>But now this introduces a subtle problem: in order to load the test modules from the &lt;code>tests&lt;/code> directory, pytest prepends the root of the repository to &lt;code>sys.path&lt;/code>, which adds the side-effect that now &lt;code>mypkg&lt;/code> is also importable.This is problematic if you are using a tool like &lt;a href="https://docs.pytest.org/en/latest/goodpractices.html#tox">tox&lt;/a> to test your package in a virtual environment, because you want to test the &lt;em>installed&lt;/em> version of your package, not the local code from the repository.&lt;/p>&lt;/blockquote>&lt;p>解释下，意思是，如果你通过添加&lt;code>__init__.py&lt;/code>改变测试目录，使其变为一个测试模块，那么pytest会将根目录添加到sys.path中，使得同级的python包mypkg也可以导入了。但是对于使用tox来多环境测试来说，这是有问题的。&lt;/p>&lt;p>所以mypkg也能导入这就是我能顺利运行pytest的原因，但是这种情况下，对tox使用不利，虽然公司的代码限定了python版本不需要使用tox。&lt;/p>&lt;p>&lt;a href="https://laike9m.com/">laike9m&lt;/a> 说conftest.py文件的机制能达到相同的效果，而且不需要&lt;code>__init__.py&lt;/code> 。&lt;/p>&lt;p>找到文档描述在&lt;a href="https://docs.pytest.org/en/latest/pythonpath.html?highlight=conftest#pytest-import-mechanisms-and-sys-path-pythonpath">这&lt;/a>&lt;/p>&lt;p>但是比较奇怪，需要人为加&lt;code>conftest.py&lt;/code> 文件在待测试包的同级别目录&lt;/p>&lt;pre>&lt;code>setup.pymypkg/ ...conftest.pytests/ foo/ __init__.py test_view1.py bar/ __init__.py test_view2.py&lt;/code>&lt;/pre>&lt;p>这样子也行。。&lt;/p>&lt;p>无论哪种做法都是利用了pytest，而不是将包安装进site-packages&lt;/p></description></item><item><title>Pyenv Guide on OSX</title><link>https://laujay.com/posts/pyenv-guide-on-osx/</link><pubDate>Wed, 01 Apr 2020 11:29:34 +0800</pubDate><guid>https://laujay.com/posts/pyenv-guide-on-osx/</guid><description>&lt;blockquote>&lt;p>好久不用。。发现都忘记怎么用了。赶紧写个笔记&lt;/p>&lt;/blockquote>&lt;h1 id="mac-osx-python开发环境配置之-pyenv">Mac OSX Python开发环境配置之 pyenv&lt;/h1>&lt;p>首先 打开terminal.app 或者 iterm2&lt;/p>&lt;p>&lt;code>$ brew install pyenv&lt;/code>&lt;/p>&lt;p>然后&lt;/p>&lt;p>&lt;code>$ pyenv versions&lt;/code>&lt;/p>&lt;p>检查pyenv安装完成与否&lt;/p>&lt;p>接着安装pyenv-virtualenv 插件&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ brew install pyenv-virtualenv&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加这几句到 .bashrc文件里&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">export PATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;~/.pyenv/bin:&lt;/span>$PATH&lt;span style="color:#e6db74">&amp;#34;&lt;/span>eval &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>pyenv init -&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>eval &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>pyenv virtualenv-init -&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后执行&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ source ~./bashrc &lt;span style="color:#75715e"># 如果是zsh就是~./zshrc 让当前环境变量生效&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用法：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ pyenv install 2.7.16$ pyenv versions system 2.7.16 2.7.16/envs/fire_env 3.6.8 3.7.2* 3.7.4 &lt;span style="color:#75715e"># 这个表示当前环境的Python解释器版本&lt;/span>$ pyenv virtualenv 2.7.16 virtual_27&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个时候你使用pyenv versions 你就会看到virtual_27&lt;/p>&lt;p>然后找个目录创建个目录叫&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ mkdir virtual_env$ cd virtual_env$ pyenv local virtual_27&lt;span style="color:#f92672">(&lt;/span>virtual_27&lt;span style="color:#f92672">)&lt;/span>$ pyenv versionssystem 2.7.16 2.7.16/envs/virtual_27 3.6.8 3.7.2 3.7.4 3.7.4/envs/374camp 374camp* virtual_27 &lt;span style="color:#f92672">(&lt;/span>set by /Users/jay/Workspace/virtual_env/virtual_27/.python-version&lt;span style="color:#f92672">)&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后你就会发现每次，进入virtual_env 就会自动激活对应的虚拟环境了,美元符号前面的会显示你当前的虚拟环境。&lt;/p>&lt;p>notes：&lt;/p>&lt;p>如果你遇到了这样的报告：&lt;/p>&lt;p>​ &lt;code> xxx export PYENV_VIRTUALENV_DISABLE_PROMPT=1 xxxx&lt;/code>&lt;/p>&lt;p>​ 那么复制&lt;code>export PYENV_VIRTUALENV_DISABLE_PROMPT=1&lt;/code> 到命令行下面执行就好了。&lt;/p>&lt;p>使用这两个工具的好处是，可以让你的电脑上存在N个不同版本的Python，并且可以进入目录切换。&lt;/p></description></item><item><title>TCP/IP网络编程</title><link>https://laujay.com/posts/tcp-ip/</link><pubDate>Sat, 28 Mar 2020 21:26:30 +0800</pubDate><guid>https://laujay.com/posts/tcp-ip/</guid><description>&lt;blockquote>&lt;p>本文图片来源于geektime网络编程实战，版权归其所有&lt;/p>&lt;/blockquote>&lt;p>网络编程的大部分内容就是设计并实现应用层协议，应用层以下的都由套接字封装了。下面逐步讲解套接字。&lt;/p>&lt;h2 id="服务器端建立连接">服务器端建立连接&lt;/h2>&lt;p>调用socket函数，返回fd（买了个电话机）&lt;/p>&lt;p>调用bind函数，分配地址信息（去电信局申请下来了电话号码）&lt;/p>&lt;p>调用listen函数，转化为🉑️接收连接状态（安装好电话线了）&lt;/p>&lt;p>调用accept函数，受理连接请求（接听电话）&lt;/p>&lt;p>总结：&lt;/p>&lt;p>第一步调用socket创建套接字。&lt;/p>&lt;p>第二步调用bind函数分配IP地址和端口号。&lt;/p>&lt;p>第三步调用listen函数转为可接收请求状态。&lt;/p>&lt;p>第四步调用accpet函数受理连接请求。&lt;/p>&lt;h3 id="客户端建立连接">客户端建立连接&lt;/h3>&lt;p>调用socket函数，返回fd（买了个电话机）&lt;/p>&lt;p>调用connect，拨通电话，等待服务器accept&lt;/p>&lt;h4 id="完整过程如下图">完整过程如下图&lt;/h4>&lt;p>&lt;img src="https://laujay.com/img/tcp-ip.png" alt="tcp-ip">&lt;/p>&lt;h3 id="套接字">套接字&lt;/h3>&lt;p>首先：协议是为了完成数据交换而定好的约定。&lt;/p>&lt;p>&lt;code>int socket(int domain, int type, int protocol)&lt;/code>&lt;/p>&lt;p>这是socket函数的声明。那么这里可以看到3个参数，第三个就是协议，这就是为什么开头要先确定协议是什么。&lt;/p>&lt;p>协议其实一般叫协议族。这个名字不是乱起的，族最字面的解释就是一大家子。比如TCP/IP名字就叫TCP/IP协议族，从头文件&lt;code>sys/socket.h&lt;/code>中可以找到以下各种协议族。&lt;/p>&lt;table>&lt;thead>&lt;tr>&lt;th>名称&lt;/th>&lt;th>协议族&lt;/th>&lt;/tr>&lt;/thead>&lt;tbody>&lt;tr>&lt;td>PF_INET&lt;/td>&lt;td>IPv4互联网协议族&lt;/td>&lt;/tr>&lt;tr>&lt;td>PF_INET6&lt;/td>&lt;td>IPv6互联网协议族&lt;/td>&lt;/tr>&lt;tr>&lt;td>PF_LOCAL&lt;/td>&lt;td>本地通信的UNIX协议族&lt;/td>&lt;/tr>&lt;tr>&lt;td>&amp;hellip;&lt;/td>&lt;td>&amp;hellip;&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>&lt;p>而第一个参数 &lt;code>domain&lt;/code>，其实就是协议族，第一个参数协议族，第三个参数是具体协议族里的某个协议。第一个参数决定了第三个参数的范围。&lt;/p>&lt;p>第二个参数 &lt;code>type&lt;/code>, 查看man手册可以看到&lt;code>SOCK_STREAM&lt;/code>, &lt;code>SOCK_DGRAM&lt;/code>, &lt;code>SOCK_RAW&lt;/code>这三种传输方式，事实上，协议族定了并不能决定传输方式。&lt;/p>&lt;p>首先无视掉&lt;code>SOCK_RAW&lt;/code>因为man下查看文档你会发现这句话 &lt;code>The type SOCK_RAW, which is available only to the super-user.&lt;/code>。&lt;/p>&lt;p>&lt;code>SOCK_STREAM&lt;/code> 这种类型的将创建面向连接的套接字。&lt;code>SOCK_STREAM类型提供基于序列的，可靠的，双向连接的字节流&lt;/code> , 因为套接字内部存在buffer，简单来说就是字节数组，只要不超过buffer的大小，所以read和write的调用次数不限，所以不存在数据边界。&lt;/p>&lt;p>&lt;code>SOCK_DGRAM&lt;/code> 这种类型将创建面向消息的套接字。&lt;code>SOCK_DGRAM类型提供不可靠、不按序传递、以数据的高速传输为目的的套接字&lt;/code>强调快速而非传输顺序。传输的数据可能丢失也可能损毁。传输的数据有边界（发几次就得收几次，而不能攒着一次收了）。限制传输的数据的大小。&lt;/p>&lt;p>第三个参数&lt;code>protocol&lt;/code>，如果一个族内一种数据传输方式的协议只有一种，严格意义上来说，前两个参数就足以确定某个协议了，但是有些族中存在一些一些有多种数据传输方式。&lt;/p>&lt;h3 id="分配ip地址和端口">分配IP地址和端口&lt;/h3>&lt;p>当获取到socket的文件描述符之后，需要分配IP地址和端口号。&lt;/p>&lt;h4 id="ip地址">IP地址&lt;/h4>&lt;p>IP地址分为两类，IPv4， IPv6。二者区别主要是字节数，目前通用的IPv4，IPv6是为了解决IP地址耗尽提出的标准。&lt;/p>&lt;p>IPv4地址是有分类的，IP地址，逻辑上分为网络号、子网号、主机号。&lt;/p>&lt;p>IP地址的分类以网络号作为区分，网络号占1字节的为A类：0～127，B类占据2字节： 128～191，c类占据3字节192～223，D类4字节。&lt;/p>&lt;p>网络的实际构成，在NAT技术下，可以理解为公网IP是一个个路由器或者交换机，实际上是先向路由器发送数据，再由路由器NAT 映射进子网内，再在子网内通过子网IP地址去(arp)找到MAC地址寻址发送过去。MAC地址只能在子网内起作用（虽然说要求全球唯一）&lt;/p>&lt;h4 id="端口号">端口号&lt;/h4>&lt;p>主机是能运行多个程序的，且大多数情况下共用同一个IP地址，为了区分哪些数据是哪些程序的。操作系统通过端口号，去分配相应的数据给对应端口的套接字（也就是相应的程序）。&lt;/p>&lt;p>端口号由16位构成，所以范围是0～65535。但是0～1023的知名端口是分配给特定应用程序的，所以一般应用分配的端口为1024～65535.&lt;/p>&lt;p>此外，TCP和UDP是不同的模块分配的，所以相同端口的UDP和TCP套接字是允许的。&lt;/p>&lt;p>IPv4地址的是以结构体的方式表示的。其结构如下:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr_in{ sa_family_t sin_family; &lt;span style="color:#75715e">//地址族&lt;/span>&lt;span style="color:#75715e">&lt;/span> uint16_y sin_port; &lt;span style="color:#75715e">//16位端口， htons()网络字节序保存&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> in_addr sin_addr; &lt;span style="color:#75715e">//32位IP地址, htons()&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> sin_zero[&lt;span style="color:#ae81ff">8&lt;/span>]; &lt;span style="color:#75715e">//不使用,为确保与sockaddr结构保持一致的填充&lt;/span>&lt;span style="color:#75715e">&lt;/span>};&lt;span style="color:#66d9ef">struct&lt;/span> in_addr{ in_addr_t s_addr; &lt;span style="color:#75715e">//32位IPv4， 网络字节序保存,htons()&lt;/span>&lt;span style="color:#75715e">&lt;/span>};&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了填充地址结构体外，传输的数据等都无需要转换字节序，因为会自动做。IPv4与IPv6及通用地址结构对比如下图:&lt;img src="https://laujay.com/img/addr-struct.png" alt="addr-struct">&lt;/p>&lt;p>IP地址是点分十进制的，为了转换成32位的整数型数据。在&lt;code>&amp;lt;arpa/inet.h&amp;gt;&lt;/code>里提供了一个函数&lt;code>in_addr_t inet_addr(const char* string);&lt;/code> 该函数会获取一个点分十进制IP地址的字符串，返回32位整数型数据并返回。&lt;/p>&lt;p>INADDR_ANY常量可以作为初始化服务器IP地址时的IP使用，因为会自动获取服务器端的计算机IP地址。&lt;/p>&lt;p>地址结构体初始化好后，可以给套接字分配地址信息。将初始化好的地址信息通过bind函数分配。&lt;/p>&lt;p>&lt;code>int bind(int socket, const struct sockaddr *address, sockelen_t address_len);&lt;/code>&lt;/p>&lt;p>sockfd经过bind这步完成后，物料已经准备好了，可以开始等待请求了。进入等待请求需要调用&lt;code>int listen(int socket, int backlog)&lt;/code> backlog是最多允许多少个连接请求进度队列。&lt;/p>&lt;p>到这里服务器的所有工作已经就绪，当有请求来的时候，其实就可以处理了。但是，由于之前那个套接字是为了接收连接请求而创建的。真正连接着客户并交换数据的是另一个套接字。可以调用&lt;code> int accept(int socket, struct sockaddr *restrict address, socklen_t *restrict address_len)&lt;/code> 来创建并连接到发起请求的客户端。&lt;/p>&lt;p>accept函数受理连接请求（backlog, 未完成连接队列的大小）中待处理的客户端连接请求。&lt;/p>&lt;p>TCP连接的server端是在accept系统调用中完成从LISTEN到SYN-RCVD（收到SYN），再到ESTABLISHED（收到ACK）的变迁过程。&lt;/p>&lt;h4 id="优雅的关闭套接字">优雅的关闭套接字&lt;/h4>&lt;p>tcp的半关闭：&lt;/p>&lt;p>Linux的close函数意味着完全断开连接。这意味着不仅不能传输也不能接收数据。&lt;/p>&lt;p>这会造成数据的损毁。那么半关闭的方法就产生了。半关闭就是将全双工的socket变为可以接收数据但无法传输，或者可以传输但无法接收。只关闭流的一半。&lt;/p>&lt;p>socket是全双工的，本质上来说 有两个流，客户端的输出流对着服务器端的输入流，客户端的输入流对着服务器端的输出流。半关闭就是断掉其中一个。&lt;/p>&lt;p>&lt;code>int shutdown(int socket, int how)&lt;/code> 两个参数分别是需要断开的套接字文件描述符和传递断开方式信息。&lt;/p>&lt;p>第二个参数有三个选项 ：&lt;/p>&lt;ul>&lt;li>SHUT_RD: 断开输入流&lt;/li>&lt;li>SHUT_WR: 断开输出流&lt;/li>&lt;li>SHUT_RDWR: 同时断开I/O流，相当于调用了两次hsutdown，第一次以SHUT_RD为参数，第二次以SHUT_WR为参数。&lt;/li>&lt;/ul>&lt;p>既要发送传输结束的信号，又要接收数据时，服务器端可以关闭输出流，通知客户端(客户端接收数据)。&lt;/p>&lt;h4 id="套接字的多种可选项">套接字的多种可选项&lt;/h4>&lt;p>套接字分层 &lt;code>IPPROTO_IP&lt;/code>层可选项是IP协议相关的， &lt;code>IPPROTO_TCP&lt;/code>是TCP协议相关的，&lt;code>SOL_SOCKET&lt;/code>是套接字相关的可选项。&lt;/p>&lt;p>&lt;code>int getsocketopt(int socket, int level, int option_name, const void *option_value, socklen_t options_len&lt;/code>) 这个函数用户读取套接字的可选项。&lt;/p>&lt;p>&lt;code> int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);&lt;/code> 这个函数用于更改可选项。&lt;/p>&lt;p>套接字类型只能在创建的时候决定，以后不能再改，也就是说tcp套接没法改成udp套接字。&lt;/p>&lt;h4 id="time-wait">TIME-WAIT&lt;/h4>&lt;p>TIME-WAIt是指主动发起方，四次握手后其实并没有真正关闭，而是会有一小段的存活期，在此期间占据的端口是无法绑定的，因为还在使用中呢。四次挥手的时候，假设是服务器端主动发起Fin，如果服务器端不存在TIME-WAIT，当服务器主动发起Fin的时候，最后一次的ACK是第一个发FIN的发出去。如果没有TIME-WAIT那么，如果这个ACK回给客户端的时候失败了，客户端会重发自己的Fin，然而这个Fin永远得不到ACK，于是会一直重传，如果服务器处于TIME-WAIT，则有机会向客户端重传最后的ACK，客户端有机会正常终止。&lt;/p>&lt;p>第二个是确保迷走报文的自动消失。客户端其实也有TIME-WAIT，只是客户端的端口是随机分配的，所以比较少绑定端口错误。&lt;/p>&lt;p>如果需要快速重启，避过TIME-WAIT，在套接字可选项中更改&lt;code>SO_REUSEADDR&lt;/code>的状态，将其改为1（真）就表示可以分配TIME-WAIT状态下的端口号。如果要解决TIMT-WAIT占用内存和占用端口的问题。需要设置 &lt;code>net.ipv4.tcp_timestamps=1(默认)&lt;/code> 以及 &lt;code>net.ipv4.tcp_tw_reuse&lt;/code>。&lt;/p>&lt;h4 id="nagle算法">Nagle算法&lt;/h4>&lt;p>TCP默认使用Nagle算法，最大限度的进行缓冲，直到之前的收到了ACK，于是将缓冲区内的全部填入一个数据报内，减少网络包数目，降低负载。&lt;/p>&lt;p>当流量未受影响时，Nagle算法用了比不用慢，典型的是传输大文件数据时。&lt;/p>&lt;p>将&lt;code>TCP_NODELAY&lt;/code> 改为1（真）就会禁用Nagle算法。&lt;/p>&lt;h1 id="知识补给">知识补给&lt;/h1>&lt;p>ssize_t 表示 signed int类型，size_t表示unsigned in类型，这么做是为了可移植性。因为操作系统的位数在增加，到时候只需要改头文件里的声明就好了。&lt;/p>&lt;p>_t结尾表示操作系统定义的数据类型。&lt;/p>&lt;p>uint16_t表示16位无符号整数&lt;/p>&lt;p>sockaddr_in是IPv4的地址信息结构体，但是sockaddr结构体不是只为IPv4设计，所以需要特别设计填充。&lt;/p>&lt;p>大端字节序：&lt;/p>&lt;p>假设内存地址是: 0x20, 0x21,0x22,0x23&lt;/p>&lt;p>那么0x12345678如果是高位在低地址&lt;/p>&lt;p>0x20 放0x12 //最高位放入地址的最低位&lt;/p>&lt;p>0x21 放0x34&lt;/p>&lt;p>0x22放 0x56&lt;/p>&lt;p>0x23放0x57&lt;/p>&lt;p>这种叫大端序也叫网络字节序。&lt;/p>&lt;p>系统有四个函数帮助转换字节序：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span> &lt;span style="color:#a6e22e">htons&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span>); &lt;span style="color:#75715e">//为端口转换&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span> &lt;span style="color:#a6e22e">ntohs&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span>); &lt;span style="color:#75715e">// 为端口转换&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">htonl&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>); &lt;span style="color:#75715e">//IP地址&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">ntohl&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>); &lt;span style="color:#75715e">//IP地址转换&lt;/span>&lt;span style="color:#75715e">// h表示主机字节序&lt;/span>&lt;span style="color:#75715e">// n表示网络字节序&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>服务器端的IP的目的在于，一台主机可以有多个NIC，添加了IP后就会决定接收该IP的数据。如果只有一个IP地址，直接使用INADDR_ANY。&lt;/p>&lt;h3 id="tcp套接字的io缓冲">TCP套接字的I/O缓冲&lt;/h3>&lt;p>write和read，write调用瞬间将数据移至输出缓冲，read函数掉用瞬间从输入缓冲读取数据。&lt;/p>&lt;ul>&lt;li>I/O缓冲在每个TCP套接字中单独存在。&lt;/li>&lt;li>I/O缓冲在创建套接字时自动生成。&lt;/li>&lt;li>即使关闭套接字也会继续传递输出缓冲中遗留的数据。&lt;/li>&lt;li>关闭套接字将丢失输入缓冲中的数据。&lt;/li>&lt;/ul></description></item><item><title>From Hexo to Hugo</title><link>https://laujay.com/posts/from-hexo-to-hugo/</link><pubDate>Sat, 22 Feb 2020 12:49:17 +0800</pubDate><guid>https://laujay.com/posts/from-hexo-to-hugo/</guid><description>&lt;p>我之前使用hexo静态博客生成器，并使用Travis CI(Continuous Integration)来自动生成并部署静态页面到GitHub Pages。&lt;/p>&lt;p>但是这有两个个问题:&lt;/p>&lt;pre>&lt;code>1. Node很麻烦，我经常装都会遇到问题。2. 不快&lt;/code>&lt;/pre>&lt;p>正好有时间，我决定尝试更换为&lt;a href="https://gohugo.io/">hugo&lt;/a>, 搜索资料后开始行动。&lt;/p>&lt;blockquote>&lt;p>这篇文章基于Claudio Jolowicz的文章&lt;a href="https://cjolowicz.github.io/posts/hosting-a-hugo-blog-on-github-pages-with-travis-ci/">Hosting a Hugo blog on GitHub Pages with Travis CI&lt;/a>&lt;/p>&lt;/blockquote>&lt;h2 id="总览">总览&lt;/h2>&lt;p>总的来说你需要做以下几件事:&lt;/p>&lt;pre>&lt;code>1. 两个github库一个叫&amp;lt;username&amp;gt;.github.io, 一个叫啥都行推荐是blog2. 创建个新的github账号，建议叫&amp;lt;username&amp;gt;-blog-bot3. 并把&amp;lt;username&amp;gt;-blog-bot设置为&amp;lt;username&amp;gt;.github.io这个库的协作者4. 设置Trvais CI，以便blog库有变更会自动生成静态页面并部署&lt;/code>&lt;/pre>&lt;h2 id="先将两个github仓库创建好">先将两个github仓库创建好&lt;/h2>&lt;p>略&lt;/p>&lt;h2 id="接着创建好新的github账号">接着创建好新的GitHub账号&lt;/h2>&lt;p>这里要说下，由于GitHub帐户必须具有唯一的电子邮件地址，因此你需要为机器人帐户使用单独的电子邮件地址。在这种情况下，一种有用的技术是子地址寻址（也称为plus addressing）：&lt;/p>&lt;pre>&lt;code>附加+blog-bot到电子邮件地址的@标志前的部分，那么发送到该地址的邮件将传递到+号前的收件箱中。&lt;/code>&lt;/pre>&lt;p>设置好了后到username.github.io的setting里加为协作者&lt;/p>&lt;h2 id="安装hugo">安装hugo&lt;/h2>&lt;p>mac OSX &lt;code>brew install hugo&lt;/code>其他参见&lt;a href="https://gohugo.io/getting-started/installing/">安装Hugo&lt;/a>&lt;/p>&lt;h2 id="设置博客库">设置博客库&lt;/h2>&lt;p>在你的电脑上 &lt;code>hugo new site blog&lt;/code>&lt;/p>&lt;pre>&lt;code>cd bloggit initgit add .git commit -m &amp;quot;Initial commit&amp;quot;&lt;/code>&lt;/pre>&lt;p>然后 &lt;code>git remote add https://github.com/username/blog.git&lt;/code>接着&lt;/p>&lt;pre>&lt;code>git submodule add \ https://github.com/budparr/gohugo-theme-ananke.git \ themes/anankegit add .git commit -m &amp;quot;Add submodule themes/ananke&amp;quot;&lt;/code>&lt;/pre>&lt;p>这里我简单选择hugo入门里推荐的这个主题, 你可以自己换个。最后 &lt;code>git psuh -u origin master&lt;/code>&lt;/p>&lt;p>将them变成你的子模块后，就可以跟踪最新的了。&lt;/p>&lt;h2 id="配置站点">配置站点&lt;/h2>&lt;p>配置在config.toml文件，主要的几个配置是&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-toml" data-lang="toml"> &lt;span style="color:#a6e22e">baseURL&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;https://username.github.io/&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">languageCode&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;zh-CN&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">title&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;我的博客&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">theme&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;ananke&amp;#34;&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改完记得提交&lt;/p>&lt;h2 id="链接部署库">链接部署库&lt;/h2>&lt;p>还是blog目录下:&lt;/p>&lt;pre>&lt;code>git submodule add \ https://github.com/username/username.github.io.git \ publicgit commit -am &amp;quot;Add submodule public&amp;quot;&lt;/code>&lt;/pre>&lt;p>public 是最后生成的静态文件所在目录，把它跟要放的存储库关联，那么之后生成好了。只要进这个目录&lt;code>git push origin master&lt;/code>就会把网站部署好了&lt;/p>&lt;h2 id="ci">CI&lt;/h2>&lt;p>利用CI的持续部署解放自己，我们只要&lt;/p>&lt;ul>&lt;li>hugo new posts/postname.md&lt;/li>&lt;li>git add content/posts&lt;/li>&lt;li>git commit -m &amp;ldquo;add post&amp;rdquo;&lt;/li>&lt;li>git push&lt;/li>&lt;/ul>&lt;p>这四个步骤就完成了一个博客文章从写到网站的所有过程&lt;/p>&lt;p>将更改（例如新文章）部署到博客实际需要几个步骤：&lt;/p>&lt;ol>&lt;li>将新文章更改推送到blog存储库。也就是上面这段&lt;/li>&lt;li>hugo被触发重建网站内容。&lt;/li>&lt;li>内容被推送到username.github.io存储库。&lt;/li>&lt;li>该存储库已部署到GitHub Pages。&lt;/li>&lt;/ol>&lt;p>好，接下来设置CI解决2，3两个步骤&lt;/p>&lt;p>在Travis CI(网址是travis-ci.org)上，用GitHub主账号登陆，找到blog这个存储库。找到设置有个叫&lt;code>environments&lt;/code>的地方,添加一个名为的&lt;code>GITHUB_AUTH_SECRET&lt;/code>环境变量。使用新创建的GitHub帐户的用户名和密码将值设置为https://user:password@github.com&lt;/p>&lt;p>在本地blog库的目录下添加文件名为&lt;code>.travis.yml&lt;/code> 的配置文件来配置Travis CI 。&lt;/p>&lt;p>blog存储库的持续集成需要执行三个任务：&lt;/p>&lt;ol>&lt;li>将Hugo安装到CI环境中。&lt;/li>&lt;li>调用Hugo命令行工具来重建站点。&lt;/li>&lt;li>将新内容部署到username.github.io。&lt;/li>&lt;/ol>&lt;p>第三步委托给Shell脚本，这是下一部分的主题。&lt;/p>&lt;p>创建.travis.yml具有以下内容的文件：&lt;/p>&lt;pre>&lt;code>---install: - curl -LO https://github.com/gohugoio/hugo/releases/download/v0.64.1/hugo_0.64.1_Linux-64bit.deb - sudo dpkg -i hugo_0.64.1_Linux-64bit.debscript: - hugodeploy: - provider: script script: bash deploy.sh skip_cleanup: true on: branch: master&lt;/code>&lt;/pre>&lt;h2 id="添加部署脚本">添加部署脚本&lt;/h2>&lt;p>在blog存储库中创建脚本，记得把下面的username替换为你的GitHub用户名：&lt;/p>&lt;pre>&lt;code>#!/bin/bashecho -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;cd publicif [ -n &amp;quot;$GITHUB_AUTH_SECRET&amp;quot; ]then touch ~/.git-credentials chmod 0600 ~/.git-credentials echo $GITHUB_AUTH_SECRET &amp;gt; ~/.git-credentials git config credential.helper store git config user.email &amp;quot;username-blog-bot@users.noreply.github.com&amp;quot; git config user.name &amp;quot;username-blog-bot&amp;quot;figit add .git commit -m &amp;quot;Rebuild site&amp;quot;git push --force origin HEAD:master&lt;/code>&lt;/pre>&lt;h2 id="最后">最后&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash"> git add .travis.yml deploy.sh git commit -am &lt;span style="color:#e6db74">&amp;#34;CI: Build and push to username.github.io&amp;#34;&lt;/span> git push&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样你访问https://username.github.io就能看到你的博客了&lt;/p>&lt;p>嗯，至于怎么加文章，自己去看hugo入门吧&lt;/p></description></item><item><title>理解Python的切片表示</title><link>https://laujay.com/posts/slice/</link><pubDate>Fri, 30 Aug 2019 10:20:13 +0800</pubDate><guid>https://laujay.com/posts/slice/</guid><description>&lt;p>原文&lt;a href="https://stackoverflow.com/questions/509211/understanding-slice-notation">understanding-slice-notaion&lt;/a>&lt;/p>&lt;p>它非常简单:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># 译者：切片用数学的区间表示的说法都是左开右闭的 [),即含左不含右&lt;/span>a[start:stop] &lt;span style="color:#75715e"># 取从start到stop-1&lt;/span>a[start:] &lt;span style="color:#75715e"># 取start到a的最后一个元素&lt;/span>a[:stop] &lt;span style="color:#75715e"># 取第0个到stop-1个元素&lt;/span>a[:] &lt;span style="color:#75715e"># 复制整个list&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还有个step(步长)的值,可以一起用:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">a[start:stop:step] &lt;span style="color:#75715e"># 从start开始包含start，到stop-1为止，取每隔step个的元素&lt;/span>&lt;span style="color:#75715e"># 译者注:&lt;/span>a &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>]a[&lt;span style="color:#ae81ff">0&lt;/span>:&lt;span style="color:#ae81ff">4&lt;/span>:&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> a[&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>]&lt;/code>&lt;/pre>&lt;/div>&lt;p>要记住的关键点是&lt;code>:stop&lt;/code>值表示不在所选中的元素中的第一值,所以stop和start他们之差是选择的元素的数量(如果step是默认值1)&lt;/p>&lt;!-- raw HTML omitted -->&lt;p>另一个特征是start或stop可能是负数，这意味着它从list的末尾而不是开头开始计数。所以:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">a[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#75715e"># 最后一个元素&lt;/span>a[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>:] &lt;span style="color:#75715e"># 最后两个元素&lt;/span>a[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#75715e"># 去除最后两个元素的数组&lt;/span>&lt;span style="color:#75715e"># 译者注: 其实就是 a[:len(a) + (-2)]&lt;/span>a &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>]a[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>]&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样，step可能是负数：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">a[::&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#75715e"># 复制整个数组，以倒序复制&lt;/span>a[&lt;span style="color:#ae81ff">1&lt;/span>::&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#75715e"># 复制从index为1往前的到开头，倒序复制&lt;/span>a[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#75715e"># 复制从-3开始结尾的元素, 倒序复制&lt;/span>a[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>::&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#75715e"># 复制从-3到开头的元素，倒序复制&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Python对程序员很友好，如果你list越界了。例如，如果取a[:-2]但是a只有一个元素，你会得到一个空的list而不是一个错误。有时候你更喜欢错误，而不是这种隐晦的结果，那么你必须要知道会有这种情况。&lt;/p>&lt;h3 id="与slice对象的关系">与slice对象的关系&lt;/h3>&lt;p>切片运算符 &lt;code>[]&lt;/code> 实际上在上面的代码中通过 &lt;code>:&lt;/code> 使用了一个slice()对象(只在[]内有效)，例如：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">a[start:stop:step]&lt;/code>&lt;/pre>&lt;/div>&lt;p>等价于&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">a[slice(start, stop, step)]&lt;/code>&lt;/pre>&lt;/div>&lt;p>Slice对象根据不同的参数会有不同的行为,跟range非常类似，比如 &lt;code>slice(stop)&lt;/code> 和&lt;code>slice(start, stop[, step])&lt;/code>。如果要跳过给定的参数，可以使用&lt;code>None&lt;/code>, 例如 &lt;code>a[start:]&lt;/code> 等价于 &lt;code>a[slice(start, None)]&lt;/code> 或者 &lt;code>a[::1]&lt;/code> 等价于&lt;code>a[slice(None, None, -1)]&lt;/code>&lt;/p>&lt;p>虽然基于 &lt;code>:&lt;/code> 符号的对于简单切片非常有用，但是显式使用slice()对象简化了使用切片时自动生成slice()对象。&lt;/p></description></item><item><title>Three Years</title><link>https://laujay.com/posts/three-years/</link><pubDate>Sat, 06 Jul 2019 15:22:13 +0800</pubDate><guid>https://laujay.com/posts/three-years/</guid><description>&lt;p>哇，终于到三年了, 时间真是可怕的东西。不知不觉已经毕业三年了，感觉自己昨天才毕业 &lt;del>装嫩&lt;/del>。&lt;/p>&lt;h2 id="工作上">工作上&lt;/h2>&lt;p>就在写完两周年总结后，我换了工作，这份工作的面试经历也是很有意思的。&lt;/p>&lt;p>第一次电话面试的方式搞定所有轮次的面试, 第一次遇到面试会问编译原理的面试官。在复试被面的怀疑人生的同时，才发现自己需要学的太多太多了，有幸能遇到这么重视基础的面试官再次提醒了自己基础的重要性。&lt;/p>&lt;p>面试完后，我从HR处得知，电话面的原因其实是，公司的技术团队目前都在马来西亚闭关修炼呢。我也是个傻大胆，就觉着出去看看也好，没觉得有啥危险，就同意去马来了，😊主要是我天朝太安全了没反应过来。到了后同事说我，胆子这么大谁都不认识就敢跑来。18年底回国后在深圳的办公室呆了半年，19年七月初又来马来西亚了，免去了深圳的通勤，还是很爽的。&lt;/p>&lt;h2 id="学习上">学习上&lt;/h2>&lt;p>面试被虐后，就开始注意补充基础知识了。学习了极客时间上的不少课程，非常推荐趣学网络，数据结构与算法之美以及左耳朵听风。并且阅读的书籍改为一些设计，架构，底层原理类的了。而不是各种框架各种技术的书。英语上按照左耳听风里的在做，并且加大了刷YouTube的时间，很多英文的英语教学视频难度不高，但是很好听懂，老师讲的也很好。听多了后自我感觉听力有所长进。&lt;/p>&lt;h2 id="生活上">生活上&lt;/h2>&lt;p>第一次出国兼坐飞机，第一次吃榴莲，第一次在国外吃火锅，太多了。在马来西亚呆了5个月不到,很有意思的经历，明明在国外，却到处是说普通话的华人以及会说普通话的老外。有些当地人虽然不会说可是却能听懂。语言上不是很大的障碍，很快就消除了陌生感以及不适应。不工作的时候就拉着同事去尝试各种食物，幸好拉着的老司机英语还是很可以的，点菜全靠他了。这次给我最大的感受是马来西亚人好少，空气好好，生活节奏超级慢。然后激发了一个英语渣学英语的心，毕竟世界这么大我想去看看呢。&lt;/p>&lt;p>Jay&lt;/p>&lt;p>2019-07-06&lt;/p>&lt;p>于马来西亚&lt;/p></description></item><item><title>Python中的正则基础</title><link>https://laujay.com/posts/re-basic/</link><pubDate>Fri, 26 Apr 2019 10:00:17 +0800</pubDate><guid>https://laujay.com/posts/re-basic/</guid><description>&lt;h2 id="python中的re">Python中的re&lt;/h2>&lt;h3 id="元字符总览">元字符总览&lt;/h3>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">.&lt;/span> &lt;span style="color:#f92672">^&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">?&lt;/span> { } [ ] \ &lt;span style="color:#f92672">|&lt;/span> ( )&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="和">&lt;code>[&lt;/code>和&lt;code>]&lt;/code>&lt;/h3>&lt;p>指定字符类， 含义是范围，匹配一组字符 &lt;code>[a-z]&lt;/code>表示所有小写字母。字符类里其他元字符不生效，在字符类里元字符被剥夺特殊性。反字符类:&lt;code>[^5]&lt;/code> 匹配除了 5外任何字符 &lt;code>^&lt;/code>必须是字符类第一个字符，不然无取反的作用。&lt;/p>&lt;h3 id="heading">&lt;code>\&lt;/code>&lt;/h3>&lt;p>反斜杠后加其他字符的组合特指特殊序列，也用于转义。要取消本身含义需要&lt;code>'\\'&lt;/code>。&lt;code>\w&lt;/code>匹配任何字母数字字符，note：依据正则表达式模式的不同，分为以字节类和Unicodedata模块中标记为字母的所有字符。在编译时提供&lt;code>re.ASCII&lt;/code>可以表示更受限制的&lt;code>\w&lt;/code>定义。&lt;/p>&lt;table>&lt;thead>&lt;tr>&lt;th>类型&lt;/th>&lt;th>含义&lt;/th>&lt;/tr>&lt;/thead>&lt;tbody>&lt;tr>&lt;td>&lt;code>\d&lt;/code>&lt;/td>&lt;td>任何十进制数字；这等价于类 [0-9]&lt;/td>&lt;/tr>&lt;tr>&lt;td>&lt;code>\D&lt;/code>&lt;/td>&lt;td>匹配任何非数字字符；这等价于类 [^0-9]&lt;/td>&lt;/tr>&lt;tr>&lt;td>&lt;code>\s&lt;/code>&lt;/td>&lt;td>匹配任何空白字符；这等价于类 [ \t\n\r\f\v]&lt;/td>&lt;/tr>&lt;tr>&lt;td>&lt;code>\S&lt;/code>&lt;/td>&lt;td>匹配任何非空白字符；这相当于类 [^ \t\n\r\f\v]&lt;/td>&lt;/tr>&lt;tr>&lt;td>&lt;code>\w&lt;/code>&lt;/td>&lt;td>匹配任何字母与数字字符；这相当于类 [a-zA-Z0-9_]&lt;/td>&lt;/tr>&lt;tr>&lt;td>&lt;code>\W&lt;/code>&lt;/td>&lt;td>匹配任何非字母与数字字符；这相当于类 [^a-zA-Z0-9_]&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>&lt;h3 id="repeat">Repeat&lt;/h3>&lt;p>&lt;code>*&lt;/code> 匹配前一个字符0～多次， 贪婪的例子： a[bcd]*b ,匹配类&lt;code>[bcd]&lt;/code>中的零或多个字母&lt;code>+&lt;/code> 匹配前一个字符1～多次&lt;code>?&lt;/code> 匹配0～1词&lt;code>{m,n}&lt;/code> 至少重复m次，最多n次。省略的话会m会是默认0，n为无限。&lt;/p>&lt;h3 id="应用匹配">应用匹配&lt;/h3>&lt;table>&lt;thead>&lt;tr>&lt;th>方法/属性&lt;/th>&lt;th>目的&lt;/th>&lt;th>&lt;/th>&lt;/tr>&lt;/thead>&lt;tbody>&lt;tr>&lt;td>match()&lt;/td>&lt;td>确定正则是否从字符串的开头匹配&lt;/td>&lt;td>&lt;/td>&lt;/tr>&lt;tr>&lt;td>search()&lt;/td>&lt;td>扫描字符串，查找此正则匹配的任何位置。&lt;/td>&lt;td>&lt;/td>&lt;/tr>&lt;tr>&lt;td>findall()&lt;/td>&lt;td>找到正则匹配的所有子字符串，并将它们作为列表返回。&lt;/td>&lt;td>&lt;/td>&lt;/tr>&lt;tr>&lt;td>finditer()&lt;/td>&lt;td>找到正则匹配的所有子字符串，并将它们返回为一个 &lt;a href="https://docs.python.org/zh-cn/3/glossary.html#term-iterator">iterator&lt;/a>&lt;/td>&lt;td>&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table></description></item><item><title>git pre-commit workflow</title><link>https://laujay.com/posts/git-pre-commit/</link><pubDate>Wed, 06 Mar 2019 20:14:29 +0800</pubDate><guid>https://laujay.com/posts/git-pre-commit/</guid><description>&lt;blockquote>&lt;p>之前看了程序人生的一篇code is law，做了点小小的实践。想起在QQ群看到一个人的分享截图，于是就想将之前做的实践查到的资料删减翻译下整理成文章，如果万一有团队内部的技术分享会还是可以分享下的。&lt;/p>&lt;/blockquote>&lt;p>我想遵循pep8，我不想手动格式化代码，我不想每次手动执行flake8来检查，甚至我不想手动执行mypy去检查我代码。&lt;/p>&lt;p>那么有什么办法呢，作为开发，日常最常执行的操作git commit必然是其中之一，无论是通过IDE的GUI工具还是命令行的方式。&lt;/p>&lt;p>通过git提供的pre-commit的hook可以在commit的时候将代码格式化，规范检查，测试等执行完毕，而不需要工程师手动做相关的操作。流程类似这样的：&lt;/p>&lt;p>&lt;img src="https://ljvmiranda921.github.io/assets/png/tuts/precommit_pipeline.png" alt="workflow">&lt;/p>&lt;p>通过采用&lt;em>pre-commit&lt;/em> 这个Python编写的库只需要以下几步就可以完成上述任务。&lt;/p>&lt;ul>&lt;li>&lt;code>pipenv install -dev pre-commit&lt;/code>&lt;/li>&lt;li>编辑.pre-commit-config.yaml&lt;/li>&lt;li>执行pre-commit install 以便在.git/目录中安装git hooks&lt;/li>&lt;/ul>&lt;!-- raw HTML omitted -->&lt;p>比如你想用black格式化代码，flak8检查代码规范，单元测试那么例子如下：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">repos&lt;/span>: &lt;span style="color:#f92672">repo&lt;/span>: &lt;span style="color:#ae81ff">local&lt;/span> &lt;span style="color:#f92672">hooks&lt;/span>: - &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">black&lt;/span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">black&lt;/span> &lt;span style="color:#f92672">language&lt;/span>: &lt;span style="color:#ae81ff">system&lt;/span> &lt;span style="color:#f92672">entry&lt;/span>: &lt;span style="color:#ae81ff">black&lt;/span> &lt;span style="color:#f92672">types&lt;/span>: [&lt;span style="color:#ae81ff">python]&lt;/span> - &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">flake8&lt;/span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">flake8&lt;/span> &lt;span style="color:#f92672">language&lt;/span>: &lt;span style="color:#ae81ff">system&lt;/span> &lt;span style="color:#f92672">entry&lt;/span>: &lt;span style="color:#ae81ff">flake8&lt;/span> &lt;span style="color:#f92672">types&lt;/span>: [&lt;span style="color:#ae81ff">python]&lt;/span> - &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">unitest&lt;/span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">unitest&lt;/span> &lt;span style="color:#f92672">language&lt;/span>: &lt;span style="color:#ae81ff">system&lt;/span> &lt;span style="color:#f92672">entry&lt;/span>: &lt;span style="color:#ae81ff">./test.sh&lt;/span> &lt;span style="color:#f92672">types&lt;/span>: [&lt;span style="color:#ae81ff">python]&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>repos是顶层的，每个hook都可以增加一个repo的section。repo存储库映射告诉pre-commit从哪里获取提现实现好的hook比如这里的flake8可以改为远程的https://github.com/pre-commit/pre-commit-hooks在上面这个例子中，由于我都在本地装了entry对应的文件，所以直接使用localentry 表示可执行的文件或者命令types 表示对哪些文件的更改起作用language 表示hook是哪些语言实现的，这里直接偷懒用系统,让他自己找&lt;/p>&lt;p>有时候我们自己的标注和pep8的略有不同，那么可以在当前目录下增加 &lt;code>.flake8&lt;/code> 来告诉flake8我们自己的客制化。&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-toml" data-lang="toml">[&lt;span style="color:#a6e22e">flake8&lt;/span>]&lt;span style="color:#a6e22e">ignore&lt;/span> = &lt;span style="color:#a6e22e">E203&lt;/span>, &lt;span style="color:#a6e22e">E266&lt;/span>, &lt;span style="color:#a6e22e">E501&lt;/span>, &lt;span style="color:#a6e22e">W503&lt;/span>, &lt;span style="color:#a6e22e">F403&lt;/span>, &lt;span style="color:#a6e22e">F401&lt;/span>&lt;span style="color:#a6e22e">max&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-&lt;/span>&lt;span style="color:#a6e22e">line&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span> = &lt;span style="color:#ae81ff">79&lt;/span>&lt;span style="color:#a6e22e">max&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-&lt;/span>&lt;span style="color:#a6e22e">complexity&lt;/span> = &lt;span style="color:#ae81ff">18&lt;/span>&lt;span style="color:#a6e22e">select&lt;/span> = &lt;span style="color:#a6e22e">B&lt;/span>,&lt;span style="color:#a6e22e">C&lt;/span>,&lt;span style="color:#a6e22e">E&lt;/span>,&lt;span style="color:#a6e22e">F&lt;/span>,&lt;span style="color:#a6e22e">W&lt;/span>,&lt;span style="color:#a6e22e">T4&lt;/span>,&lt;span style="color:#a6e22e">B9&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>&lt;li>本文章原文及本文的图片来自&lt;a href="https://ljvmiranda921.github.io/notebook/2018/06/21/precommits-using-black-and-flake8/">这里&lt;/a> 版权归原作者所有&lt;/li>&lt;/ul></description></item><item><title>Env is Evil: ycmd server SHUT DOWN Unexpected exit code -11</title><link>https://laujay.com/posts/env-is-evil/</link><pubDate>Tue, 27 Nov 2018 07:30:01 +0800</pubDate><guid>https://laujay.com/posts/env-is-evil/</guid><description>&lt;h2 id="what-issue">What issue?&lt;/h2>&lt;p>The ycmd server SHUT DOWN (restart with &amp;lsquo;:YcmRestartServer&amp;rsquo;). Unexpected exit code -11.&lt;/p>&lt;h2 id="try-fix">Try fix&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">./install.py --clang-completercd ~/.vim/bundle/YouCompleteMe/third_party/ycmdcd ycmdcp default_settings.json ..python ycmd --options_file default_settingspython3 ./build.py&lt;/code>&lt;/pre>&lt;/div>&lt;p>Not working.&lt;/p>&lt;p>When reading source code, I found out the &lt;code>build.py&lt;/code> uses sysconfig.I try to add pdb.set_trace() in the first line of function GetPossiblePythonLibraryDirectories.In pdb shell p sysconfig.get_config_var(&amp;ldquo;LIBPL&amp;rdquo;), result show path is fault, not mine.I try hard code absolute path in GetPossiblePythonLibraryDirectories, but no working.&lt;/p>&lt;h2 id="fixed">Fixed&lt;/h2>&lt;p>Anyway, in ycm issues i found out miniconda3 has conflict issue.&lt;/p>&lt;p>so try:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">rm &lt;span style="color:#f92672">-&lt;/span>rf miniconda3python3 install&lt;span style="color:#f92672">.&lt;/span>py&lt;/code>&lt;/pre>&lt;/div>&lt;p>Well, it&amp;rsquo;s working.Environment implicit is evil, explicit is better than implicit.&lt;/p></description></item><item><title>ASGI规范中文版</title><link>https://laujay.com/posts/asgi-zh-cn/</link><pubDate>Wed, 17 Oct 2018 07:00:39 +0800</pubDate><guid>https://laujay.com/posts/asgi-zh-cn/</guid><description>&lt;h1 id="异步服务网关接口asynchronous-server-gateway-interface-规范">异步服务网关接口(Asynchronous Server Gateway Interface) 规范&lt;/h1>&lt;p>&lt;em>Version&lt;/em>:2.0(2017-11-28)&lt;/p>&lt;h2 id="摘要">摘要&lt;/h2>&lt;p>本文档描述了基于网络协议服务器（尤其是web服务器）和 Python 应用之间的标准接口，希望能够处理多种通用协议(包括 HTTP、HTTP2 和 WebSocket)。&lt;/p>&lt;p>这个基本规范目的在于定义这些服务器交互并运行应用的API集合；每个支持的协议（例如HTTP) 都有一个子规范，概述如何将协议编码和解码报文。&lt;/p>&lt;h2 id="依据">依据&lt;/h2>&lt;p>WSGI 规范自诞生以来应用广泛，让 Python 框架和 web 服务器的选择上有很大的自由。然而，因为设计的与 HTTP 风格的请求响应模型的耦合太强，加上越来越多不遵循这种模式的协议逐渐成为 web 编程的标准之一，比如说，WebSocket。ASGI 尝试在保证应用接口简单的前提下，提供一个允许数据能够在任意时候、被任意应用进程发送和接受的抽象。&lt;/p>&lt;p>它同样采用将协议转换为Python兼容，异步友好的消息集的原则，并将其概括为两部分：一个关于构建服务器的标准通信接口，以及一组用于每个协议的标准通信协议。&lt;/p>&lt;p>它主要的目标是提供一个编写HTTP/2 和WebSocket，以及一般的HTTP应用代码的方式。然而，&lt;/p>&lt;p>这种设计一部分是确保有简单的途径来兼容现有的WSGI服务器与应用代码，为绝大多数依赖WSGI的Python web 项目提供一个继续运行的简单方式，这是很重要的一点。具体的细节在ASGI-HTTP规范里描述。&lt;/p>&lt;h2 id="总览">总览&lt;/h2>&lt;p>ASGI由两个不同的组件组成&lt;/p>&lt;ul>&lt;li>一个&lt;em>协议服务&lt;/em> ，其用来终止sockets与转换他们成为一个连接于每个连接的事件信息&lt;/li>&lt;li>一个&lt;em>应用代码&lt;/em> ，它位于协议服务内，每个连接都会实例化一次，并在事件发生时进行处理&lt;/li>&lt;/ul>&lt;p>与WSGI类似的是，应用运行于服务容器中，服务容器以标准格式向应用发送请求。然而与WSGI不同的是，应用是实例化的对象，他们是处理事件，而非简单可调用的，并且他们必须是兼容&lt;code>asyncio&lt;/code>的协程（在主线程上，如果需要运行同步的代码，可以自由的使用线程或其他进程）&lt;/p>&lt;p>与WSGI不同的是，一个ASGI有两个独立的连接部分：&lt;/p>&lt;ul>&lt;li>&lt;em>连接域&lt;/em> ，代表着一个协议连接到一个用户，并持续到连接被关闭&lt;/li>&lt;li>事件，发生在连接时发送给应用&lt;/li>&lt;/ul>&lt;p>应用在一个连接域内被实例化，然后在事件循环中被触发执行处理事件，最后发送数据给客户端。&lt;/p>&lt;p>每个应用实例都映射到一个独立的“socket”或者连接，如果要进行清理操作，预计会在该连接的预设生存期再加一段时间。 有些协议可能不使用传统的套接字; ASGI针对这些协议将定义范对应的（实例）生命域以及何时关闭。&lt;/p>&lt;h2 id="规范细节">规范细节&lt;/h2>&lt;h3 id="连接域">连接域&lt;/h3>&lt;p>用户到ASGI应用的每个连接都将产生一个应用实例。连接的持续域与建立连接时获得得信息，统称为&lt;em>连接域&lt;/em>。&lt;/p>&lt;p>例如： 在HTTP连接域下只会持续一个请求，但是它已经包含大多数的请求信息(除了HTTP request body外，因为它通过流来传递事件)。&lt;/p>&lt;p>但是，在WebSocket协议里，只要socket连着，连接就会不断持续着。这个域包含的信息像是Websocket的路径，但是传入的信息等细节则是以事件的形式出现的。&lt;/p>&lt;p>有些协议可能会提供一个连接，但只有非常有限的信息，因为他们封装了握手之类的东西。每个协议定义都必须包含关于连接持续多长的信息，与能从中获得哪种类型的信息。&lt;/p>&lt;p>应用程序在被初始化与给定连接域时不能与客户端进行通信；他们必须等待到事件循环根据协议规范运行，可能必须等到初次打开的信息。&lt;/p>&lt;h2 id="事件">事件&lt;/h2>&lt;p>ASGI将协议分解为一系列应用程序必须响应的&lt;em>事件&lt;/em>，这有序的两个事件很简单-&lt;code>http.request&lt;/code>与&lt;code>http.disconnect&lt;/code>。针对像WebSocket，可能是&lt;code>websocket.connect，websocket.send，websocket.receive，websocket.disconnect&lt;/code>。&lt;/p>&lt;p>每个事件都是一个&lt;code>dict&lt;/code>并带着一个顶层&lt;code>type&lt;/code>key，包含信息类型的一个unicode 字符串。使用者可以自由的建立他们自己的消息类型，并在应用实例间发送他们以处理高级事件-举个例子，一个聊天程序可能会发送一个&lt;code>mychat.message&lt;/code>类型的聊天信息。预估应用程序可以处理多种事件类型混合的事件集，其中一些来自客户端连接，另外一些则来自应用的其它部分。&lt;/p>&lt;p>因为这些信息可能来自其它网络，他们需要被序列化，因此信息被要求只能包含以下几种类型：&lt;/p>&lt;ul>&lt;li>Byte strins&lt;/li>&lt;li>Unicode strings&lt;/li>&lt;li>Integers (within the signed 64 bit range)&lt;/li>&lt;li>Floating point numbers (within the IEEE 754 double precision range, no &lt;code>Nan&lt;/code> or infinities)&lt;/li>&lt;li>Lists (tuples should be encoded as lists)&lt;/li>&lt;li>Dicts (keys must be unicode strings)&lt;/li>&lt;li>Booleans&lt;/li>&lt;li>&lt;code>None&lt;/code>&lt;/li>&lt;/ul>&lt;h2 id="应用">应用&lt;/h2>&lt;p>ASGI应用被定义成可调用的:&lt;/p>&lt;p>&lt;code>application(scope)应用（域）&lt;/code>&lt;/p>&lt;ul>&lt;li>&lt;code>域&lt;/code>: 连接域，一个至少包含一个&lt;code>type&lt;/code>key所指定传入协议的字典&lt;/li>&lt;/ul>&lt;p>每当一个新的连接进入协议服务器，这个第一个可调用的对象在有新连接时会被调用并建立一个新的&lt;em>实例&lt;/em> （这个实例时一个新的对象，第一次被调用时候返回）&lt;/p>&lt;p>这个调用时一个同步的，且不同包含阻塞调用（建议只作为存储的域）。假如你需要执行阻塞的工作，则必须在下一个可以调用的开始时执行它，然后你的应用才会进入await等待事件执行完。&lt;/p>&lt;p>他必须返回另一个，awaitable的调用：&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#960050;background-color:#1e0010">协程&lt;/span> application_instance(receive, send)&lt;/code>&lt;/pre>&lt;/div>&lt;ul>&lt;li>&lt;p>&lt;code>receive&lt;/code>，一个awaitable调用的函数，当可用的时候他会&lt;code> yield&lt;/code> 一个新的事件字典事件&lt;/p>&lt;/li>&lt;li>&lt;p>&lt;code>send&lt;/code>, 一个awaitable调用的单个事件字典作为一个位置参数，一但发送完成就会返回&lt;/p>&lt;/li>&lt;/ul>&lt;p>这个设计也许更容易被认为是一个可能的实现，像是一个类:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Python" data-lang="Python">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>: &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, scope): self&lt;span style="color:#f92672">.&lt;/span>scope &lt;span style="color:#f92672">=&lt;/span> scope async &lt;span style="color:#66d9ef">def&lt;/span> __call__(self, receive, send): &lt;span style="color:#f92672">...&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应用程序接口一般情况下传入两个可调用对象，看起来会像是工厂函数(类)或者是基于分配器来提供更好的可扩展性。&lt;/p>&lt;p>无论scope或者你接收或发送的报文格式都是基于应用协议的。scope必须是一个dict，键scope[&amp;ldquo;type&amp;rdquo;]始终存在，并可用于确定使用的协议类型。&lt;/p>&lt;p>协议特定的子规范包含了这些scope和报文的格式。他们相当于WSGI规范定义的字典中的&lt;code>environ&lt;/code>键。&lt;/p>&lt;h2 id="协议规范">协议规范&lt;/h2>&lt;p>这里描述各种协议的标准化域和报文格式。&lt;/p>&lt;p>一个在所有的域和报文中都存在的公共键是&lt;code>type&lt;/code>, 用于表明正在接收哪种类型的域或者报文。&lt;/p>&lt;p>在域中，&lt;code>type&lt;/code>键必须是一个unicode字符串，像是&amp;quot;http&amp;quot;或者是&amp;quot;websocket&amp;quot;,如相关协议规范中的定义所示。&lt;/p>&lt;p>在 报文中，类型应命名为&lt;code>protocol.message_type&lt;/code>，其中协议与域类型匹配，&lt;code>message_type&lt;/code>由协议规范定义。消息类型值的示例包括&lt;code>http.request&lt;/code>和&lt;code>websocket.send&lt;/code>&lt;/p>&lt;p>当前协议规范:&lt;/p>&lt;ul>&lt;li>&lt;a href="https://github.com/django/asgiref/blob/master/specs/www.rst">HTTP and WebSocket&lt;/a>&lt;/li>&lt;/ul>&lt;h2 id="中间件">中间件&lt;/h2>&lt;p>有可能会有ASGI中间件，代码同时具有服务器和应用两种角色， 又接受一个域和发送/接收的awaitables，可能修改这个awaitables，然后调用更底层的应用。&lt;/p>&lt;p>当一个中间件修改域的时候，应该要在域对象的副本进行改变，并将副本传入底层应用之前进行修改，否则更改可能影响上层。需要注意的是，您不应该假设您传给应用的域的副本是其最终使用的域的副本，因为底层可能是其他中间件；因此，不要保留对它的引用，并尝试将它改变为传递的初始ASGI构造器可调用的的域。&lt;/p>&lt;p>值得注意的是，ASGI应用的一部分域同步运行，它的目的在于与Python类构造函数兼容。如果你需要将对象放入阻塞/异步工作的域中，则可以让他们是awaitable的，或着在协程的入口创建可以填写的对象（记住，对象必须是可以修改的；您无法保留对域的引用并尝试稍后添加键）。&lt;/p>&lt;h2 id="错误处理">错误处理&lt;/h2>&lt;p>如果服务器收到一个无效的事件字典-比如，一个未知类型，缺少应该有的键，或者用错了Python对象的类型（比如对于HTTP headers Unicode字符串），它应该抛出一个awaitable的异常 &lt;code>send&lt;/code>给应用。&lt;/p>&lt;p>如果应用收到无效的事件字典，&lt;code>receive&lt;/code>应该引发异常。&lt;/p>&lt;p>在这两种情况下，事件字典中的其他键的存在都不应该引发异常。这是为了允许随着事件的推移对协议规范进行不间断的升级。&lt;/p>&lt;p>服务器可以自由的展示错误，这些错误会从他们正在运行的应用实例中抛出，但是他们希望在控制台打印log，发送到系统日志或者其他操作-但是如果发生这种情况，他们必须终止应用程序实例以及其关连的连接。&lt;/p>&lt;h2 id="扩展">扩展&lt;/h2>&lt;p>有时候基于ASGI协议的服务器可能希望在核心ASGI协议规范之外提供特定服务器的扩展，或者在规范的更改被发布之前进行试运行。&lt;/p>&lt;p>对于这种情况，我们定义了一个通用模式&lt;code>extensions&lt;/code>-对协议规范的名称添加是可选的，但如果由服务器提供并由应用程序解析，则可用于获取更多功能。&lt;/p>&lt;p>这是通过字典中的一个 &lt;code>extensions&lt;/code>字段，其本身值就是一个字典。扩展名由一个在服务器和应用程序之间达成一致的unicode字符串名称。&lt;/p>&lt;p>如果服务器支持扩展名，它应该在&lt;code>extensions&lt;/code>值对应的字典内加入一个扩展名，扩展名对应的值也是一个字典。&lt;/p>&lt;p>服务器可以提供任何额外的域信息，这些信息属于该字典值中扩展的那部分，或者如果扩展只是表明服务器通过&lt;code>send&lt;/code> 可调用函数接受附加事件，则它可能是一个空字典。&lt;/p>&lt;p>一个例子是，假设HTTP协议服务器希望提供一个扩展，允许将新事件发送回尝试通过操作系统刷新网络发送缓存区的服务器。它在扩展字典中提供一个空的字段来表明它可以处理该事件:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">scope &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#e6db74">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;method&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;GET&amp;#34;&lt;/span>, &lt;span style="color:#f92672">...&lt;/span> &lt;span style="color:#e6db74">&amp;#34;extensions&amp;#34;&lt;/span>: { &lt;span style="color:#e6db74">&amp;#34;fullflush&amp;#34;&lt;/span>: {}, },}&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果应用获取到这个空字段，它就知道它可以发送自定义事件（通过类型为&lt;code>http.fullflush&lt;/code>的&lt;code>send&lt;/code>调用）。&lt;/p>&lt;h3 id="字符串与unicode">字符串与Unicode&lt;/h3>&lt;p>在本文档和所有子规范中，字节字符串指的是 bytes Python3中的类型。Unicode字符串指的&lt;code>str&lt;/code>是Python3中的类型。&lt;/p>&lt;p>这个文档永远不会指定字符串-所有string都是两种确切类型之一。&lt;/p>&lt;p>所有的字典key（包括域和事件）都是unicode字符串。&lt;/p>&lt;h2 id="version-history">Version History&lt;/h2>&lt;ul>&lt;li>2.0 (2017-11-28): Initial non-channel-layer based ASGI spec&lt;/li>&lt;/ul>&lt;h2 id="copyright">Copyright&lt;/h2>&lt;p>This document has been placed in the public domain.&lt;/p></description></item><item><title>Coroutine</title><link>https://laujay.com/posts/coroutine/</link><pubDate>Sun, 15 Jul 2018 18:20:13 +0800</pubDate><guid>https://laujay.com/posts/coroutine/</guid><description>&lt;h2 id="fluent-python阅读笔记">Fluent Python阅读笔记&lt;/h2>&lt;h2 id="从可迭代对象说起">从可迭代对象说起&lt;/h2>&lt;h3 id="迭代器">迭代器&lt;/h3>&lt;p>使用iter内置函数可以获取迭代器的对象，如果对象实现了&lt;code>__iter__&lt;/code>，而&lt;code>__iter__&lt;/code>一般返回迭代器，那么对象就是可迭代的。序列都可以迭代，实现了&lt;code>__getitem__&lt;/code>方法，并且参数从零开始索引的也可以迭代。&lt;/p>&lt;p>可迭代对象和迭代器之间的关系是: Python从可迭代的对象中获取迭代器。迭代器是实现了无参数&lt;code>__next__&lt;/code>方法的对象，使用next内置方法能返回对象中下个元素并实现了&lt;code>__iter__&lt;/code>，而&lt;code>__iter__&lt;/code>一般返回实例本身，这样可以将迭代器本身当可迭代对象用。可迭代对象一定不能是自身的迭代器，也就是不能实现&lt;code>__next__&lt;/code>方法(反模式)。&lt;/p>&lt;p>所以过程是这样滴：假设有个s = Sentence(&amp;ldquo;Pig and Pepper&amp;rdquo;)it = iter(s)iter -&amp;gt; 调用了&lt;code>__iter__&lt;/code>于是iter返回了s本身next -&amp;gt; 调用了&lt;code>__next__&lt;/code>于是返回序列中下一个&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> Sentence(&lt;span style="color:#e6db74">&amp;#39;Pig and Pepper&amp;#39;&lt;/span>)&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> iter(s)&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> next(it) &lt;span style="color:#e6db74">&amp;#39;Pig&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> next(it)&lt;span style="color:#e6db74">&amp;#39;and&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> next(it)&lt;span style="color:#e6db74">&amp;#39;Pepper&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> next(it)Traceback (most recent call last): &lt;span style="color:#f92672">...&lt;/span>&lt;span style="color:#a6e22e">StopIteration&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> list(it) &lt;span style="color:#75715e">#&lt;/span>[]&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> list(iter(s)) &lt;span style="color:#75715e"># [&amp;#39;Pig&amp;#39;, &amp;#39;and&amp;#39;, &amp;#39;Pepper&amp;#39;]&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="yield与生成器">yield与生成器&lt;/h3>&lt;p>Python函数的定义体中有yield关键字，该函数就是生成器函数， 生成器函数是生成器工厂，但生成器工厂不是只有包含yield的才是，只要返回一个生成器就是生成器工厂。&lt;/p>&lt;p>生成器是迭代器，会生成传给yield 关键字的表达式的值。因为生成器是迭代器，所以调用next 会获取yield 生成的下一个元素。&lt;/p>&lt;p>在Python 3.3 之前，如果生成器函数中的return 语句有返回值，那么会报错。现在可以这么做，不过return 语句仍会导致 StopIteration 异常抛出。并且调用方可以从异常中获取返回值，这点在把生成器当协程用的时候有意义。&lt;/p>&lt;p>生成器有个语法糖叫生成器表达式：(for i in list)，这种由括号括起来的是创建生成器的简洁句法。&lt;/p>&lt;h3 id="生成器加上send就变协程">生成器加上send就变协程&lt;/h3>&lt;p>大概是引入yield的五年后PEP342为生成器增加了额外的方法和功能，主要是&lt;code>.send()&lt;/code> 与&lt;code>.__next__()&lt;/code> 方法一样，&lt;code>.send()&lt;/code> 方法致使生成器前进到下一个 yield 语句。不 过，&lt;code>.send()&lt;/code> 方法还允许使用生成器的客户把数据发给自己，即不管传给 &lt;code>.send()&lt;/code> 方法什么参数，那个参数都会成为生成器函数。定义体中对应的yield 表达式的值。也就是说，&lt;code>.send()&lt;/code> 方法允许在客户代码和生成器之间双向交换数据。而 .&lt;strong>next&lt;/strong>() 方法只允许客户从生成器中获取数据。&lt;/p>&lt;p>PEP 342 还添加了&lt;code>.throw(...)&lt;/code> 和 &lt;code>.close()&lt;/code> 方法:前者的作用是让调用方抛出异常，在生成器中处理;后者的作用是终止生成器。&lt;/p>&lt;h2 id="协程示例">协程示例&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">In [&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">simple_coroutine&lt;/span>(): &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;-&amp;gt; coroutine startd&amp;#39;&lt;/span>) &lt;span style="color:#f92672">...&lt;/span>: x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">yield&lt;/span> &lt;span style="color:#75715e"># 只从调用端接收数据&lt;/span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;-&amp;gt; coroutine received:&amp;#39;&lt;/span>, x) &lt;span style="color:#f92672">...&lt;/span>:In [&lt;span style="color:#ae81ff">3&lt;/span>]: my_coro &lt;span style="color:#f92672">=&lt;/span> simple_coroutine()In [&lt;span style="color:#ae81ff">4&lt;/span>]: my_coroOut[&lt;span style="color:#ae81ff">4&lt;/span>]: &lt;span style="color:#f92672">&amp;lt;&lt;/span>generator object simple_coroutine at &lt;span style="color:#ae81ff">0x1079f0308&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>In [&lt;span style="color:#ae81ff">5&lt;/span>]: next(my_coro)&lt;span style="color:#f92672">-&amp;gt;&lt;/span> coroutine startdIn [&lt;span style="color:#ae81ff">6&lt;/span>]: my_coro&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#ae81ff">42&lt;/span>) &lt;span style="color:#75715e"># 发送数据给协程&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span> coroutine received: &lt;span style="color:#ae81ff">42&lt;/span> &lt;span style="color:#75715e"># 打印最后一句，函数执行定义体的末尾，抛出StopIteration&lt;/span>&lt;span style="color:#f92672">---------------------------------------------------------------------------&lt;/span>&lt;span style="color:#a6e22e">StopIteration&lt;/span> Traceback (most recent call last)&lt;span style="color:#f92672">&amp;lt;&lt;/span>ipython&lt;span style="color:#f92672">-&lt;/span>input&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>c96f97a77cb&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>module&lt;span style="color:#f92672">&amp;gt;&lt;/span>()&lt;span style="color:#f92672">----&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> my_coro&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#ae81ff">42&lt;/span>)&lt;span style="color:#a6e22e">StopIteration&lt;/span>:&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个是基于生成器的协程，定义体中包含yield协程处于四个状态:&amp;lsquo;GEN_CREATED&amp;rsquo;: 等待开始执行&amp;lsquo;GEN_RUNNING&amp;rsquo;: 解释器正在执行&amp;lsquo;GEN_SUSPENDED&amp;rsquo;: 在yield表达式处暂停&amp;lsquo;GEN_CLOSED&amp;rsquo;: 执行结束&lt;/p>&lt;p>始终要调用 next(my_coro) 激活协程——也可以调用 my_coro.send(None)，效果一样。如果没激活就发送None之外的值会报错:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python"> Traceback (most recent call last): File &lt;span style="color:#e6db74">&amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;&lt;/span>, line &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">in&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>module&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">TypeError&lt;/span>: can&lt;span style="color:#e6db74">&amp;#39;t send non-None value to a just-started generator&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="yield-from">yield from&lt;/h2>&lt;p>yield from :• 子生成器产出的值都直接传给委派生成器的调用方(即客户端代码)。• 使用 send() 方法发给委派生成器的值都直接传给子生成器。如果发送的值是 None，那么会调用子生成器的 &lt;code>__next__()&lt;/code> 方法。如果发送的值不是 None，那么会调用子生成器的send() 方法。如果调用的方法抛出 StopIteration 异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。• 生成器退出时，生成器(或子生成器)中的 return expr 表达式会触发 StopIteration(expr)异常抛出。• yield from 表达式的值是子生成器终止时传给 StopIteration 异常的第一个参数。&lt;/p></description></item><item><title>Two Years</title><link>https://laujay.com/posts/two-years/</link><pubDate>Fri, 06 Jul 2018 20:20:13 +0800</pubDate><guid>https://laujay.com/posts/two-years/</guid><description>&lt;p>两年了，总觉得该总结下了。工作一年的时候没啥心思。虽然现在处境不算好，但是内心强大多了。&lt;/p>&lt;hr>&lt;p>2016年的7月4号，是毕业后工作的第一天。记得那天，天气不错，我当时到了后由于没人招待还问了我们公司没人事么，记得很清楚CEO笑着说了句要什么人事。&lt;/p>&lt;p>感谢那些人，大家很好。那时候，大伙没事就去咖啡馆里拿杯咖啡，我经常蹭咖啡，然后被老司机们带喝起了美式，正好我有点乳糖不耐又蛮喜欢苦味的，倒喝的很开心。&lt;/p>&lt;p>有段时间经常周六，或者周日就跑公司的咖啡馆里或者别的附近的咖啡馆里跟一两个同事聊天、学习、加班。那时候很简单，泡壶茶，坐一天。节奏很舒服，环境很舒服。&lt;/p>&lt;p>随着时间的推移，渐渐的我做的和我想做的就开始有偏差了，随着公司的需求写着不同的语言用着不同的框架。不喜欢一个东西就会下意识排斥，于是就变成了下班后学习的和工作完全无关，而实践中用，下班后咀嚼白天的体会查缺补漏，觉得才是很好自我提升的道路。可是我不是这样子的路线，我觉得我需要些改变，于是问自己，我想做什么，擅长做什么。&lt;/p>&lt;p>当然，我肯定是没想清楚，不过我大致想做什么的想法了，于是在8月，我离开了，比较任性的裸辞了。&lt;/p>&lt;hr>&lt;p>之后的之后，我换了城市，做起了我喜欢的Python开发，感谢读书时认识的那些人，素未谋面，但是他（她）们打开了我的视野，让我知道了Python。用着喜欢的Python，到现在，九个月了。&lt;/p>&lt;p>这九个月，身边的人来来去去，让我认识到了深圳速度。。而在之前，身边的人从认识到熟悉到离开，节奏远无法与现在相比。&lt;/p>&lt;p>工作上负责起以前不会做的，数据库设计，部署，运维。以前有人负责部署和运维，导致我对项目上线整个流程没什么了解，只负责开发。有了这些体会再回想当时领导对我说的关于项目目录结构以及配置文件的一些做法有了更深的认知。别人说了怎么做会避免坑，但是只知道生搬硬套免不了还是会犯错的，往往只有真的再踩了一次才能有深刻啊。&lt;/p>&lt;p>技术上比当初眉毛胡子一把抓，所主次了。买了不少书，电子的纸质的都有，电子的读了不少，纸质读的却不多。打算把这些书看完，然 多抓鱼卖二手去，之后只买电子不买纸质了。&lt;/p>&lt;p>Jay&lt;/p>&lt;p>2018-07-07&lt;/p>&lt;p>于深圳&lt;/p></description></item><item><title>Pathlib</title><link>https://laujay.com/posts/pathlib/</link><pubDate>Tue, 29 May 2018 10:20:20 +0800</pubDate><guid>https://laujay.com/posts/pathlib/</guid><description>&lt;p>在上次Python3 unknown 里我记录了Python3新加的一个库pathlib，还给了如下一个example&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">from&lt;/span> pathlib &lt;span style="color:#f92672">import&lt;/span> Pathdirectory &lt;span style="color:#f92672">=&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;/etc&amp;#34;&lt;/span>)filepath &lt;span style="color:#f92672">=&lt;/span> directory &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hosts&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> filepath&lt;span style="color:#f92672">.&lt;/span>exists(): &lt;span style="color:#66d9ef">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;hosts exist&amp;#39;&lt;/span>)&lt;/code>&lt;/pre>&lt;/div>&lt;p>不得不说path的操作真是高频。。最近写的项目里我就用了好几次，写在这里增加下example:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">from&lt;/span> pathlib &lt;span style="color:#f92672">import&lt;/span> Path&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">load_tdk&lt;/span>(section_name): root &lt;span style="color:#f92672">=&lt;/span> Path(__file__)&lt;span style="color:#f92672">.&lt;/span>parent&lt;span style="color:#f92672">.&lt;/span>parent config &lt;span style="color:#f92672">=&lt;/span> root &lt;span style="color:#f92672">/&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;conf/tdk.json&amp;#34;&lt;/span>) tdk &lt;span style="color:#f92672">=&lt;/span> json&lt;span style="color:#f92672">.&lt;/span>loads(config&lt;span style="color:#f92672">.&lt;/span>read_text()) &lt;span style="color:#f92672">...&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里将网站的seo的tdk.json文件导入并使用。省略了业务逻辑。这里展示的是获取到配置文件的目录，并且可以直接用read_text()将文件打开并以文本方式读取，还能以其他方式读取这里不展开了。&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">parent &lt;span style="color:#f92672">=&lt;/span> Path(Path&lt;span style="color:#f92672">.&lt;/span>cwd())&lt;span style="color:#f92672">.&lt;/span>parentprivate_key_pem &lt;span style="color:#f92672">=&lt;/span> parent &lt;span style="color:#f92672">/&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;conf/app_private_key.pem&amp;#34;&lt;/span>)public_key &lt;span style="color:#f92672">=&lt;/span> parent &lt;span style="color:#f92672">/&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;conf/alipay_public.key&amp;#34;&lt;/span>)app_private_key_path&lt;span style="color:#f92672">=&lt;/span>private_key_pem&lt;span style="color:#f92672">.&lt;/span>as_posix(),alipay_public_key_path&lt;span style="color:#f92672">=&lt;/span>public_key&lt;span style="color:#f92672">.&lt;/span>as_posix(),&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是更熟悉之后的做法, Path.cwd() 类似于linux的命令pwd获取从root到当前路径的绝对地址as_posix方法将包含文件名的路径转为字符串。&lt;/p></description></item><item><title>不知道的Python3特性</title><link>https://laujay.com/posts/python3-unknow/</link><pubDate>Sat, 12 May 2018 22:20:19 +0800</pubDate><guid>https://laujay.com/posts/python3-unknow/</guid><description>&lt;p>下面这几个是我日常基本没使用过的特性。&lt;/p>&lt;h2 id="高级解包">高级解包&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># in python2&lt;/span>In [&lt;span style="color:#ae81ff">2&lt;/span>]: a, b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>In [&lt;span style="color:#ae81ff">3&lt;/span>]: a, b &lt;span style="color:#f92672">=&lt;/span> b, a&lt;span style="color:#75715e"># now in python3&lt;/span>In [&lt;span style="color:#ae81ff">4&lt;/span>]: a, b, &lt;span style="color:#f92672">*&lt;/span>rest &lt;span style="color:#f92672">=&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)In [&lt;span style="color:#ae81ff">5&lt;/span>]: &lt;span style="color:#66d9ef">print&lt;/span>(a)&lt;span style="color:#ae81ff">0&lt;/span>In [&lt;span style="color:#ae81ff">6&lt;/span>]: &lt;span style="color:#66d9ef">print&lt;/span>(b)&lt;span style="color:#ae81ff">1&lt;/span>In [&lt;span style="color:#ae81ff">7&lt;/span>]: &lt;span style="color:#66d9ef">print&lt;/span>(rest)[&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>]In [&lt;span style="color:#ae81ff">8&lt;/span>]: a, &lt;span style="color:#f92672">*&lt;/span>rest, b &lt;span style="color:#f92672">=&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)In [&lt;span style="color:#ae81ff">9&lt;/span>]: &lt;span style="color:#66d9ef">print&lt;/span>(a)&lt;span style="color:#ae81ff">0&lt;/span>In [&lt;span style="color:#ae81ff">10&lt;/span>]: &lt;span style="color:#66d9ef">print&lt;/span>(rest)[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>]In [&lt;span style="color:#ae81ff">11&lt;/span>]: &lt;span style="color:#66d9ef">print&lt;/span>(b)&lt;span style="color:#ae81ff">9&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="强制关键词参数">强制关键词参数&lt;/h2>&lt;p>如果不想用*args收集多余参数你可能这么写&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">In [&lt;span style="color:#ae81ff">14&lt;/span>]: &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mysum&lt;/span>(a, b, biteme&lt;span style="color:#f92672">=&lt;/span>False): &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">if&lt;/span> biteme: &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;一键删库&amp;#39;&lt;/span>) &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">else&lt;/span>: &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b &lt;span style="color:#f92672">...&lt;/span>:In [&lt;span style="color:#ae81ff">15&lt;/span>]: mysum(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>)Out[&lt;span style="color:#ae81ff">15&lt;/span>]: &lt;span style="color:#ae81ff">3&lt;/span>In [&lt;span style="color:#ae81ff">16&lt;/span>]: mysum(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#75715e"># if this is delete DB?&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">一键删库&lt;/span>In [&lt;span style="color:#ae81ff">18&lt;/span>]: &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mysum&lt;/span>(a, b, &lt;span style="color:#f92672">*&lt;/span>, biteme&lt;span style="color:#f92672">=&lt;/span>False): &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">if&lt;/span> biteme: &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;一键删库&amp;#39;&lt;/span>) &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">else&lt;/span>: &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b &lt;span style="color:#f92672">...&lt;/span>:In [&lt;span style="color:#ae81ff">19&lt;/span>]: mysum(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#75715e"># now raise TypeError&lt;/span>&lt;span style="color:#f92672">---------------------------------------------------------------------------&lt;/span>&lt;span style="color:#a6e22e">TypeError&lt;/span> Traceback (most recent call last)&lt;span style="color:#f92672">&amp;lt;&lt;/span>ipython&lt;span style="color:#f92672">-&lt;/span>input&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">19&lt;/span>&lt;span style="color:#f92672">-&lt;/span>eb8c192f30fb&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>module&lt;span style="color:#f92672">&amp;gt;&lt;/span>()&lt;span style="color:#f92672">----&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> mysum(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>)&lt;span style="color:#a6e22e">TypeError&lt;/span>: mysum() takes &lt;span style="color:#ae81ff">2&lt;/span> positional arguments but &lt;span style="color:#ae81ff">3&lt;/span> were given&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="新的标准库">新的标准库&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">In [&lt;span style="color:#ae81ff">22&lt;/span>]: &lt;span style="color:#f92672">import&lt;/span> ipaddressIn [&lt;span style="color:#ae81ff">23&lt;/span>]: &lt;span style="color:#66d9ef">print&lt;/span>(ipaddress&lt;span style="color:#f92672">.&lt;/span>ip_address(&lt;span style="color:#e6db74">&amp;#39;192.168.0.1&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">print&lt;/span>(ipaddress&lt;span style="color:#f92672">.&lt;/span>ip_address(&lt;span style="color:#e6db74">&amp;#39;2001:db8::&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">...&lt;/span>:&lt;span style="color:#ae81ff">192.168&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">0.1&lt;/span>&lt;span style="color:#ae81ff">2001&lt;/span>:db8::In [&lt;span style="color:#ae81ff">24&lt;/span>]: &lt;span style="color:#f92672">from&lt;/span> functools &lt;span style="color:#f92672">import&lt;/span> lru_cache &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#f92672">from&lt;/span> urllib.error &lt;span style="color:#f92672">import&lt;/span> HTTPError &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#f92672">import&lt;/span> urllib.request &lt;span style="color:#f92672">...&lt;/span>:In [&lt;span style="color:#ae81ff">25&lt;/span>]: &lt;span style="color:#a6e22e">@lru_cache&lt;/span>(maxsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>) &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_pep&lt;/span>(num): &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;Retrieve text of a Python Enhancement Proposal&amp;#39;&lt;/span> &lt;span style="color:#f92672">...&lt;/span>: resource &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;http://www.python.org/dev/peps/pep-&lt;/span>&lt;span style="color:#e6db74">%04d&lt;/span>&lt;span style="color:#e6db74">/&amp;#39;&lt;/span> &lt;span style="color:#f92672">%&lt;/span> num &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">try&lt;/span>: &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">with&lt;/span> urllib&lt;span style="color:#f92672">.&lt;/span>request&lt;span style="color:#f92672">.&lt;/span>urlopen(resource) &lt;span style="color:#66d9ef">as&lt;/span> s: &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> s&lt;span style="color:#f92672">.&lt;/span>read() &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">except&lt;/span> HTTPError: &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Not Found&amp;#39;&lt;/span> &lt;span style="color:#f92672">...&lt;/span>:&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="pahtlib">pahtlib&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">from&lt;/span> pathlib &lt;span style="color:#f92672">import&lt;/span> Pathdirectory &lt;span style="color:#f92672">=&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;/etc&amp;#34;&lt;/span>)filepath &lt;span style="color:#f92672">=&lt;/span> directory &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hosts&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> filepath&lt;span style="color:#f92672">.&lt;/span>exists(): &lt;span style="color:#66d9ef">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;hosts exist&amp;#39;&lt;/span>)&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个比通常用os库做的优雅多了。。特别是filepath这句特别黑魔法, 把dunder方法&lt;code>__div__&lt;/code>用的很溜。&lt;/p></description></item><item><title>Tornado执行阻塞函数</title><link>https://laujay.com/posts/tornado-run-blocking-function/</link><pubDate>Wed, 18 Apr 2018 09:32:17 +0800</pubDate><guid>https://laujay.com/posts/tornado-run-blocking-function/</guid><description>&lt;h2 id="使用tornado时执行阻塞函数的姿势">使用Tornado时执行阻塞函数的姿势&lt;/h2>&lt;p>很多人使用Tornado的姿势其实都是不对的，很多人都是知乎style地使用Tornado，当然这话是大佬说的。我脑补了下才反应过来什么叫知乎style，其实就指用Tornado，但是代码里却很多阻塞的。Tornado的文档guide里异步和非阻塞I/O节第二段就说了：&lt;code>为了尽量减少并发连接造成的开销，Tornado使用了一种单线程事件循环的方式。 这就意味着所有的应用代码都应该是异步非阻塞的, 因为在同一时间只有一个操作是有效的.&lt;/code>敲黑板了，这是官方原话，所以这就是正确的使用Tornado的姿势没跑了。&lt;/p>&lt;h2 id="所以有以下的操作让耗时的阻塞操作变异步的方式">所以有以下的操作让耗时的阻塞操作变异步的方式&lt;/h2>&lt;p>董伟明大佬的博文&lt;a href="http://www.dongwm.com/archives/shi-yong-tornadorang-ni-de-qing-qiu-yi-bu-fei-zu-sai/">使用tornado让你的请求异步非阻塞&lt;/a>说了我知道的和不知道的方式，欢迎补充。&lt;/p>&lt;h2 id="官方的做法是">官方的做法是？&lt;/h2>&lt;p>我想改变公司的知乎style代码，就去啃了下文档，才有了这篇文章的由来，在翻最新的5.x版本文档里，我想起了以前有些卡时间的操作都用了&lt;code>run_on_exexutor&lt;/code>于是就翻到这个函数的文档，然后发现文档里多了句这个&lt;code> In general, using run_in_executor when calling a blocking method is recommended instead of using this decorator when defining a method.&lt;/code>什么时候出现的难道是我以前看英文没认真。于是搜了下这个函数在&lt;a href="http://www.tornadoweb.org/en/stable/guide/coroutines.html#calling-blocking-functions">这里&lt;/a>在文档里看到了这个示例:&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#a6e22e">@gen.coroutine&lt;/span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">call_blocking&lt;/span>(): &lt;span style="color:#66d9ef">yield&lt;/span> IOLoop&lt;span style="color:#f92672">.&lt;/span>current()&lt;span style="color:#f92672">.&lt;/span>run_in_executor(blocking_func, args)&lt;/code>&lt;/pre>&lt;/div>&lt;p>UPDATE: 这里其实文档有错，在我提的issue之后，文档更为如下，一共需要三个参数&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">async &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">call_blocking&lt;/span>(): await IOLoop&lt;span style="color:#f92672">.&lt;/span>current()&lt;span style="color:#f92672">.&lt;/span>run_in_executor(None, blocking_func, args)&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后跟一个大佬分享了，大佬说那这个blocking_func是任意的都可以么，于是带着这个疑问我再翻了下文档，点过去看到了这个函数的声明与注释，原来是5.0新加的。&lt;code>Runs a function in a concurrent.futures.Executor&lt;/code> 看到concurrent你们会想到啥，反正我脑子里冒出了ThreadPool和ProcessPool。&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python"> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">run_in_executor&lt;/span>(self, executor, func, &lt;span style="color:#f92672">*&lt;/span>args): &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;Runs a function in a ``concurrent.futures.Executor``. If&lt;/span>&lt;span style="color:#e6db74"> ``executor`` is ``None``, the IO loop&amp;#39;s default executor will be used.&lt;/span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74"> Use `functools.partial` to pass keyword arguments to ``func``.&lt;/span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74"> .. versionadded:: 5.0&lt;/span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> ThreadPoolExecutor &lt;span style="color:#f92672">is&lt;/span> None: &lt;span style="color:#66d9ef">raise&lt;/span> &lt;span style="color:#a6e22e">RuntimeError&lt;/span>( &lt;span style="color:#e6db74">&amp;#34;concurrent.futures is required to use IOLoop.run_in_executor&amp;#34;&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span> executor &lt;span style="color:#f92672">is&lt;/span> None: &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">not&lt;/span> hasattr(self, &lt;span style="color:#e6db74">&amp;#39;_executor&amp;#39;&lt;/span>): &lt;span style="color:#f92672">from&lt;/span> tornado.process &lt;span style="color:#f92672">import&lt;/span> cpu_count self&lt;span style="color:#f92672">.&lt;/span>_executor &lt;span style="color:#f92672">=&lt;/span> ThreadPoolExecutor(max_workers&lt;span style="color:#f92672">=&lt;/span>(cpu_count() &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>)) executor &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>_executor c_future &lt;span style="color:#f92672">=&lt;/span> executor&lt;span style="color:#f92672">.&lt;/span>submit(func, &lt;span style="color:#f92672">*&lt;/span>args) &lt;span style="color:#75715e"># Concurrent Futures are not usable with await. Wrap this in a&lt;/span> &lt;span style="color:#75715e"># Tornado Future instead, using self.add_future for thread-safety.&lt;/span> t_future &lt;span style="color:#f92672">=&lt;/span> Future() self&lt;span style="color:#f92672">.&lt;/span>add_future(c_future, &lt;span style="color:#66d9ef">lambda&lt;/span> f: chain_future(f, t_future)) &lt;span style="color:#66d9ef">return&lt;/span> t_future&lt;/code>&lt;/pre>&lt;/div>&lt;p>源码如上, 清晰明了，官方也是简单粗暴，耗时的我再开个线程池来处理就好了。以后如果阻塞的函数都可以用这个run_in_executor了。这样你的代码就能用正确的姿势跑在Tornado框架里了。&lt;/p>&lt;p>UPDATE: 我之前提到文档有错，在我提的issue之后，原本以为会从代码层面更改，结果只改了文档。然后我提了说这个做法不够优雅，实现run_in_executor的老外说，虽然是有点尴尬，不过asyncio也是这么处理的，那没辙就这样吧.感兴趣的可以看&lt;a href="https://github.com/tornadoweb/tornado/issues/2493">这里&lt;/a>&lt;/p>&lt;p>UPDATE: 我在上文写到了其实现简单粗暴，另开线程。这里要分享的一个坑就是与此相关的。&lt;/p>&lt;p>最近写的一个东西，使用了很早之前的torndb, 为了不阻塞，使用这个函数去跑，由于会有很高的写数据库。于是该系统很不稳定，经过排查发现之前这么用没出现问题，一个是因为当时没使用run_int_executor，而是上篇说的很阻塞的使用。在那种情况下由于tornado的单线程机制，不会有竞争，基本单数据库连接就够了。而如今用了很多多线程进行写后，数据连接的单例单连接, 而没有用连接池, 就会出现问题了。&lt;/p></description></item><item><title>CentOS升级HTTPS</title><link>https://laujay.com/posts/deploy_and_using_https/</link><pubDate>Thu, 28 Dec 2017 21:38:29 +0800</pubDate><guid>https://laujay.com/posts/deploy_and_using_https/</guid><description>&lt;h2 id="升级https">升级https&lt;/h2>&lt;p>最近需要将域名升级为https, 以满足安全性和一些第三方接口的要求。目前的技术栈为前端VUE, 后端为Tornado。Tornado负责接口的实现。&lt;/p>&lt;h2 id="具体步骤">具体步骤&lt;/h2>&lt;p>&lt;code>curl https://get.acme.sh | sh&lt;/code> 安装acme.sh&lt;/p>&lt;p>&lt;code>source ~/.bashrc &lt;/code>&lt;code>acme.sh --issue -d www.your-app.com -w /home/work/www/your-app/current/public&lt;/code> 这里的public需要通过域名外网可访问&lt;/p>&lt;pre>&lt;code>acme.sh --installcert -d www.your-app.com \ --keypath /home/work/www/ssl/www.your-app.com.key \ --fullchainpath /home/work/www/ssl/www.your-app.com.key.pem \ --reloadcmd &amp;quot;sudo service nginx force-reload&amp;quot;&lt;/code>&lt;/pre>&lt;p>这里是ubuntu上的用法,而我用的服务器是CentOS系统的,所以最后一句需要改为&lt;/p>&lt;pre>&lt;code>--reloadcmd &amp;quot;sudo systemctl reload nginx&amp;quot;&lt;/code>&lt;/pre>&lt;p>最后一句为了免密执行需要再设置下:&lt;code>sudo visudo&lt;/code>&lt;code>work ALL=(ALL) NOPASSWD: /bin/systemctl reload nginx&lt;/code> # work 是工作目录生成 dhparam.pem 文件:&lt;code>openssl dhparam -out /home/work/www/ssl/dhparam.pem 2048&lt;/code>&lt;/p>&lt;h2 id="遇到的问题">遇到的问题&lt;/h2>&lt;p>首先需要解决的是证书, 关于这点acme.sh解决了这个问题, 详细内容可以看参考。当生成证书, 写好nginx配置的时候, 测试配置的时候直接报错&lt;code>unknown directive &amp;quot;ssl&amp;quot;&lt;/code>。很明显ssl不支持, 查看配置确实是最初编译的时候没加入http_ssl_module,随后重新编译加上&lt;code>--with-http_ssl_module&lt;/code>, 于是就解决了这个问题。&lt;/p>&lt;h2 id="配置nginx">配置Nginx&lt;/h2>&lt;pre>&lt;code>server { listen 443 ssl; server_name subdomain.dommain.com; ssl_certificate /home/work/path/subdomain.domain.com.key.pem; ssl_certificate_key /home/work/path/subdomain.domain.com.key; ssl_dhparam /home/work/path/dhparam.pem;ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ...}&lt;/code>&lt;/pre>&lt;h2 id="http-强制跳转https">http 强制跳转https&lt;/h2>&lt;pre>&lt;code>server { listen 80;server_name subdomain.domain.com; rewrite /(.*) https://$http_host/$1 redirect;}&lt;/code>&lt;/pre>&lt;h2 id="最后检查并重启nginx">最后检查并重启nginx&lt;/h2>&lt;p>这个具体的命令依据不同版本的系统而不同, 更多内容看参考文章。&lt;/p>&lt;h2 id="使用-acmesh-给-nginx-安装-let-s-encrypt-提供的免费-ssl-证书httpsruby-chinaorgtopics31983">&lt;a href="https://ruby-china.org/topics/31983">使用 acme.sh 给 Nginx 安装 Let’ s Encrypt 提供的免费 SSL 证书&lt;/a>&lt;/h2>&lt;h2 id="--web">title: CentOS升级HTTPSdate: 2017-12-28 21:38:29categories: Nginxtags:- https- nginx- web&lt;/h2>&lt;h2 id="升级https-1">升级https&lt;/h2>&lt;p>最近需要将域名升级为https, 以满足安全性和一些第三方接口的要求。目前的技术栈为前端VUE, 后端为Tornado。Tornado负责接口的实现。&lt;/p>&lt;h2 id="具体步骤-1">具体步骤&lt;/h2>&lt;p>&lt;code>curl https://get.acme.sh | sh&lt;/code> 安装acme.sh&lt;/p>&lt;p>&lt;code>source ~/.bashrc &lt;/code>&lt;code>acme.sh --issue -d www.your-app.com -w /home/work/www/your-app/current/public&lt;/code> 这里的public需要通过域名外网可访问&lt;/p>&lt;pre>&lt;code>acme.sh --installcert -d www.your-app.com \ --keypath /home/work/www/ssl/www.your-app.com.key \ --fullchainpath /home/work/www/ssl/www.your-app.com.key.pem \ --reloadcmd &amp;quot;sudo service nginx force-reload&amp;quot;&lt;/code>&lt;/pre>&lt;p>这里是ubuntu上的用法,而我用的服务器是CentOS系统的,所以最后一句需要改为&lt;/p>&lt;pre>&lt;code>--reloadcmd &amp;quot;sudo systemctl reload nginx&amp;quot;&lt;/code>&lt;/pre>&lt;p>最后一句为了免密执行需要再设置下:&lt;code>sudo visudo&lt;/code>&lt;code>work ALL=(ALL) NOPASSWD: /bin/systemctl reload nginx&lt;/code> # work 是工作目录生成 dhparam.pem 文件:&lt;code>openssl dhparam -out /home/work/www/ssl/dhparam.pem 2048&lt;/code>&lt;/p>&lt;h2 id="遇到的问题-1">遇到的问题&lt;/h2>&lt;p>首先需要解决的是证书, 关于这点acme.sh解决了这个问题, 详细内容可以看参考。当生成证书, 写好nginx配置的时候, 测试配置的时候直接报错&lt;code>unknown directive &amp;quot;ssl&amp;quot;&lt;/code>。很明显ssl不支持, 查看配置确实是最初编译的时候没加入http_ssl_module,随后重新编译加上&lt;code>--with-http_ssl_module&lt;/code>, 于是就解决了这个问题。&lt;/p>&lt;h2 id="配置nginx-1">配置Nginx&lt;/h2>&lt;pre>&lt;code>server { listen 443 ssl; server_name subdomain.dommain.com; ssl_certificate /home/work/path/subdomain.domain.com.key.pem; ssl_certificate_key /home/work/path/subdomain.domain.com.key; ssl_dhparam /home/work/path/dhparam.pem;ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ...}&lt;/code>&lt;/pre>&lt;h2 id="http-强制跳转https-1">http 强制跳转https&lt;/h2>&lt;pre>&lt;code>server { listen 80;server_name subdomain.domain.com; rewrite /(.*) https://$http_host/$1 redirect;}&lt;/code>&lt;/pre>&lt;h2 id="最后检查并重启nginx-1">最后检查并重启nginx&lt;/h2>&lt;p>这个具体的命令依据不同版本的系统而不同, 更多内容看参考文章。&lt;/p>&lt;p>&lt;a href="https://ruby-china.org/topics/31983">使用 acme.sh 给 Nginx 安装 Let’ s Encrypt 提供的免费 SSL 证书&lt;/a>&lt;/p></description></item><item><title>Pickle Error</title><link>https://laujay.com/posts/pickle-error/</link><pubDate>Tue, 17 Oct 2017 13:52:34 +0800</pubDate><guid>https://laujay.com/posts/pickle-error/</guid><description>&lt;h3 id="error-message">Error Message&lt;/h3>&lt;pre>&lt;code>cPickle.PicklingError: Can't pickle&lt;/code>&lt;/pre>&lt;h3 id="shell">shell&lt;/h3>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">python3 -m trace -tg --ignore-dir /Library $1&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="bug-code">bug code&lt;/h3>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">process_way&lt;/span>(): workers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> futures&lt;span style="color:#f92672">.&lt;/span>ProcessPoolExecutor(workers) &lt;span style="color:#66d9ef">as&lt;/span> executor: futs &lt;span style="color:#f92672">=&lt;/span> {executor&lt;span style="color:#f92672">.&lt;/span>submit(blocking_way) &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)} &lt;span style="color:#66d9ef">return&lt;/span> len([fut&lt;span style="color:#f92672">.&lt;/span>result() &lt;span style="color:#66d9ef">for&lt;/span> fut &lt;span style="color:#f92672">in&lt;/span> futs])&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="reason">Reason&lt;/h3>&lt;pre>&lt;code>Pool methods all use a queue.Queue to pass tasks to the worker processes.Everything that goes through the queue.Queue must be pickable.So, multiprocessing can only transfer Python objects to worker processes which can be pickled.Functions are only picklable if they are defined at the top-level of a module, bound methods are not picklable.&lt;/code>&lt;/pre>&lt;h3 id="fixed">Fixed&lt;/h3>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">process_way&lt;/span>(): workers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> futures&lt;span style="color:#f92672">.&lt;/span>ThreadPoolExecutor(workers) &lt;span style="color:#66d9ef">as&lt;/span> executor: futs &lt;span style="color:#f92672">=&lt;/span> {executor&lt;span style="color:#f92672">.&lt;/span>submit(blocking_way) &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)} &lt;span style="color:#66d9ef">return&lt;/span> len([fut&lt;span style="color:#f92672">.&lt;/span>result() &lt;span style="color:#66d9ef">for&lt;/span> fut &lt;span style="color:#f92672">in&lt;/span> futs])&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Blog Ci</title><link>https://laujay.com/posts/blog-ci/</link><pubDate>Sat, 15 Jul 2017 13:40:17 +0800</pubDate><guid>https://laujay.com/posts/blog-ci/</guid><description>&lt;p>比较早之前，我的博客用的是jeklly, 当时各种换插件和配置都很麻烦, 后来果断切到了hexo。当时想要用CI来做博客的自动生成，也省得每次换电脑都要重新安装hexo，可惜当时搞岔了travis的配置，导致次生成静态页面后push到github的候就挂了。于是一放就是几个月，这两天捡起来重新做，终于发现问题出在哪里了，于是记录下。&lt;/p>&lt;p>第一个问题是&lt;code>_config.yml&lt;/code>&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">deploy&lt;/span>: &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">git&lt;/span> &lt;span style="color:#f92672">repo&lt;/span>: &lt;span style="color:#ae81ff">git@github.com:pyclear/pyclear.github.io.git&lt;/span> &lt;span style="color:#f92672">branch&lt;/span>: &lt;span style="color:#ae81ff">master&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里需要用ssh方式而不是http方式。&lt;/p>&lt;p>第二个是我查了好久的，一个travis的安全措施导致，就算执行成功了还不会停下而是超时失败。解决这个问题需要在.travis.yml里ssh-add那这么写&lt;/p>&lt;pre>&lt;code class="language-ymal" data-lang="ymal">- eval $(ssh-agent -s)- ssh-agent -k&lt;/code>&lt;/pre>&lt;p>ssh-agent后需要执行带k参数的，把ssh-agent进程杀掉不然travis由于有进程在跑，会没有输出，就算执成功了状态依旧会显示执行失败的。&lt;/p></description></item><item><title>Argparse</title><link>https://laujay.com/posts/argparse/</link><pubDate>Fri, 09 Dec 2016 22:19:43 +0800</pubDate><guid>https://laujay.com/posts/argparse/</guid><description>&lt;p>argparse是一个命令行解析的标准库，通过参数可以根据add_argument()的action选项触发不同的action。&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># arg-demo.py&lt;/span>&lt;span style="color:#f92672">import&lt;/span> argparse&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_args&lt;/span>(): parser &lt;span style="color:#f92672">=&lt;/span> argparse&lt;span style="color:#f92672">.&lt;/span>ArgumentParser( description&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;demo argument parser&amp;#34;&lt;/span>, epilog&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;example usage&amp;#34;&lt;/span> ) parser&lt;span style="color:#f92672">.&lt;/span>add_argument(&lt;span style="color:#e6db74">&amp;#39;-l&amp;#39;&lt;/span>,action&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;show&amp;#34;&lt;/span>, required&lt;span style="color:#f92672">=&lt;/span>True, help&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Help text for option x&amp;#39;&lt;/span>) parser&lt;span style="color:#f92672">.&lt;/span>add_arguemtn(&lt;span style="color:#e6db74">&amp;#39;-a&amp;#39;&lt;/span>,help&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;show all file&amp;#34;&lt;/span>,default&lt;span style="color:#f92672">=&lt;/span>False) &lt;span style="color:#66d9ef">print&lt;/span>(parser&lt;span style="color:#f92672">.&lt;/span>parse_args()) &lt;span style="color:#75715e"># parse_args()用来参数解析&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>: get_args() &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>python3 arg_demo&lt;span style="color:#f92672">.&lt;/span>py &lt;span style="color:#f92672">-&lt;/span>x testing &lt;span style="color:#75715e"># Namespace(l=&amp;#39;testing&amp;#39;, a=False)&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>required=True保证了在命令调用的时候一定要上-l参数,也就是其他都是可选参数而－l参数是必须的。输出的结果显示带参数执行会在namespace里加上参数和参数值, 完全可以理解为命令空间内的全局变量。default保证了&lt;code>－a&lt;/code>参数的默认值为False, 实际上如果不加的话，如果使用的时候没使用这个参数。那么默认值为None。&lt;/p>&lt;p>显然，现在例子中的都是可以同时使用的参数。有些时候一些参数提供的功能没法同时使用，这时候需要使用互斥分组,&lt;code>add_mutually_execlusive_group&lt;/code>&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">group &lt;span style="color:#f92672">=&lt;/span> parser&lt;span style="color:#f92672">.&lt;/span>add_mutually_exclusive_group()group&lt;span style="color:#f92672">.&lt;/span>add_argument(&lt;span style="color:#e6db74">&amp;#39;-l&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;--execute&amp;#39;&lt;/span>,action&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;show&amp;#34;&lt;/span>, help&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Help text for option x&amp;#39;&lt;/span>)group&lt;span style="color:#f92672">.&lt;/span>add_arguemtn(&lt;span style="color:#e6db74">&amp;#39;-a&amp;#39;&lt;/span>,help&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;show all file&amp;#34;&lt;/span>,default&lt;span style="color:#f92672">=&lt;/span>False)&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果同时使用这两参数的话，会报错:&lt;/p>&lt;blockquote>&lt;p>error: argument -a: not allowed with argument -l/&amp;ndash;execute&lt;/p>&lt;/blockquote></description></item><item><title>Functools</title><link>https://laujay.com/posts/functools/</link><pubDate>Sat, 03 Dec 2016 20:49:16 +0800</pubDate><guid>https://laujay.com/posts/functools/</guid><description>&lt;h2 id="functools-module">functools module&lt;/h2>&lt;p>functools 模块包含了非常多很有用的函数，甚至可以说是比较常用的。这些函数主要用于创建高阶函数、函数式编程和装饰器的函数和装饰器。&lt;/p>&lt;h2 id="partial">partial&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python"> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">spam&lt;/span>(a,b,c,d): &lt;span style="color:#66d9ef">print&lt;/span>(a,b,c,d) &lt;span style="color:#f92672">from&lt;/span> functools &lt;span style="color:#f92672">import&lt;/span> partial s1 &lt;span style="color:#f92672">=&lt;/span> partial(spam,&lt;span style="color:#ae81ff">1&lt;/span>) s1(&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>) &lt;span style="color:#75715e"># 1,2,3,4&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在类定义中使用partial, 那么这个函数的行为类似于静态方法而不是实例方法。&lt;/p>&lt;h2 id="reducefunction-items-initial">reduce(function, items [,initial])&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python"> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a,b): &lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">+&lt;/span>b &lt;span style="color:#f92672">from&lt;/span> functools &lt;span style="color:#f92672">import&lt;/span> reduce reduce(add, [i &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">11&lt;/span>)]) &lt;span style="color:#75715e"># 55&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从可迭代对象中取前两个值，交给作为第一个参数传入的处理函数处理(类似map的第一个参数)，完了再将函数的返回值与可迭代对象中的下一个值作为处理函数的值。从这可以知道这个处理函数必须要能接受两个参数。&lt;/p>&lt;h2 id="update_warpper">update_warpper&lt;/h2>&lt;p>我在之前的python-note中记录过一点，简单来说就是为了能够保有原始函数的包括docstring在内的一些属性而提供的。然而每次调用update_warpper不方便, 于是就有了下一小节的warps。&lt;/p>&lt;h2 id="warps">warps&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">from&lt;/span> functools &lt;span style="color:#f92672">import&lt;/span> wraps&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">corator&lt;/span>(func): &lt;span style="color:#a6e22e">@wraps&lt;/span>(func) &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">wrapper&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>args, &lt;span style="color:#f92672">**&lt;/span>kwargs): &lt;span style="color:#66d9ef">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;calling decorated function ..&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> wrapper&lt;span style="color:#a6e22e">@corator&lt;/span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>(): &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#e6db74"> docstring&lt;/span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;called test function&amp;#39;&lt;/span>)&lt;span style="color:#66d9ef">print&lt;/span>(test&lt;span style="color:#f92672">.&lt;/span>__name__,test&lt;span style="color:#f92672">.&lt;/span>__doc__) &lt;span style="color:#75715e"># test docstring&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与update_warpper功能类似，但身为装饰器更容易使用。&lt;/p></description></item><item><title>Collections</title><link>https://laujay.com/posts/collections/</link><pubDate>Tue, 29 Nov 2016 23:35:32 +0800</pubDate><guid>https://laujay.com/posts/collections/</guid><description>&lt;h2 id="collections-module">collections module&lt;/h2>&lt;p>collections提供了些新类型：deque和defaultdict, namedtuple等。&lt;/p>&lt;h2 id="deque">deque&lt;/h2>&lt;p>deque是性能非常高的，插入和删除优化到接近O(1),并且具有很有意思的特性。&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python"> &lt;span style="color:#f92672">from&lt;/span> collections &lt;span style="color:#f92672">import&lt;/span> deque dq &lt;span style="color:#f92672">=&lt;/span> deque([&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>],&lt;span style="color:#ae81ff">12&lt;/span>) &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">15&lt;/span>): dq&lt;span style="color:#f92672">.&lt;/span>append(i) &lt;span style="color:#75715e">#添加到右端&lt;/span> id(dq[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#75715e">#4297546624&lt;/span> id(dq[&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#75715e">#4297546656&lt;/span> dq&lt;span style="color:#f92672">.&lt;/span>append(&lt;span style="color:#ae81ff">18&lt;/span>) id(dq[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#75715e">#4297546656&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用id来看添加值前后的内存地址会发现现的一个有意思的地方, 如果限制了大小，当满了以后那么添加新项目的话，会在相反的一端删除对象，添加了一个值后dq[0]的id变成了原来dq[1]的id值, 原来dq[0]里面的内容也被删除了, 这样的实现无疑保证了性能。&lt;/p>&lt;p>deque是双端队列，在插入的时侯性能极好并且deque是线程安全的，appendleft和append是用来分别在左端和右端添加数据。&lt;/p>&lt;p>还有个基于双端数据结构的函数：rotate, 它可以轻易的旋转所有项，rotate的参数值大小决定旋转步数，正负决定旋转方向, 正向右转，负向左转。&lt;/p>&lt;h2 id="defaultdict">defaultdict&lt;/h2>&lt;p>与字典基本一样，除了对不存在的键将调用default_factory提供的函数来提供默认值，实际上与字典get取值设置默认值类似，只不过换成key不存在设置该key的值，并将这个key与所调用函数生成的值保存起来.&lt;/p>&lt;h2 id="namedtuple">namedtuple&lt;/h2>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python"> &lt;span style="color:#f92672">from&lt;/span> collections &lt;span style="color:#f92672">import&lt;/span> namedtuple NetAddress &lt;span style="color:#f92672">=&lt;/span> nametuple(&lt;span style="color:#e6db74">&amp;#39;NetAddress&amp;#39;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;hostname&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;port&amp;#39;&lt;/span>]) a &lt;span style="color:#f92672">=&lt;/span> NetAddress(&lt;span style="color:#e6db74">&amp;#39;localhost&amp;#39;&lt;/span>,&lt;span style="color:#ae81ff">80&lt;/span>) a&lt;span style="color:#f92672">.&lt;/span>hostname &lt;span style="color:#75715e"># &amp;#39;localhost&amp;#39;&lt;/span> a&lt;span style="color:#f92672">.&lt;/span>port &lt;span style="color:#75715e"># 80&lt;/span> type(a) &lt;span style="color:#75715e"># ipython output __main__.NetAddress &lt;/span> isinstance(a, tuple) &lt;span style="color:#75715e"># True&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实是构造了一个tuple的子类, 可以使用各种tuple的方法，但却提供了更方便的数据结构，isinstance验证了这点。namedtuple具备更小的内存消耗，但是.方式的属性访问没类快。&lt;/p>&lt;h2 id="源码">源码&lt;/h2>&lt;p>有个点得记下，看collections的源码的时候发现，其使用了个_collections模块, 在标准库根本找不到，后来在爆站找到答案，居然是个内置库，c写的。&lt;/p></description></item><item><title>glob</title><link>https://laujay.com/posts/glob/</link><pubDate>Sun, 27 Nov 2016 19:24:16 +0800</pubDate><guid>https://laujay.com/posts/glob/</guid><description>&lt;h2 id="glob-module">glob module&lt;/h2>&lt;p>glob通过匹配来查找文件，该模块暴露出来三个函数glob, iglob, escape&lt;/p>&lt;h2 id="glob">glob&lt;/h2>&lt;p>glob通过简单的匹配规则查找文件例如:*匹配所有?匹配一个字符&lt;/p>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> globglob&lt;span style="color:#f92672">.&lt;/span>glob(&lt;span style="color:#e6db74">&amp;#39;*&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># 返回当前目录下所有的文件&lt;/span>glob&lt;span style="color:#f92672">.&lt;/span>glob(&lt;span style="color:#e6db74">&amp;#39;?.*&amp;#39;&lt;/span>) &lt;span style="color:#75715e">#返回所有文件名是一个字符的文件&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="iglob">iglob&lt;/h2>&lt;p>iglob与glob其实是一回事，区别在于一个返回list一个返回iter。事实上通过阅读代码你会发现，glob其实就是调用iglob,然后用list函数将iter值取出生成list&lt;/p>&lt;h2 id="escape">escape&lt;/h2>&lt;p>escapse功能比较简单，就转义掉特殊字符&lt;/p></description></item><item><title>Requests Encoding</title><link>https://laujay.com/posts/requests-encoding/</link><pubDate>Wed, 24 Aug 2016 20:48:15 +0800</pubDate><guid>https://laujay.com/posts/requests-encoding/</guid><description>&lt;h2 id="问题">问题&lt;/h2>&lt;p>我一直以为按照meta去搞编码就ok了，然而事实上是然并卵。。例子之一是199IT的网页，看到meta charset=&amp;ldquo;utf-8&amp;rdquo;在使用requests获取网页的时候，发现搞下来的中文文本都是乱码(response.text)。于是一脸懵逼的开始转码，开始试都不行直到试到了ISO－8859-1于是我就奇怪了，怎么搞的，然后我就开始搜索和研究。&lt;/p>&lt;h2 id="试验">试验&lt;/h2>&lt;p>第一步自然是怀疑requests了，因为我试过用wget获取发现毫无问题。于是就去看requests文档，发现了这么一段：&lt;/p>&lt;p>&lt;code>When you receive a response, Requests makes a guess at the encoding to use for decoding the response when you access the Response.text attribute. Requests will first check for an encoding in the HTTP header, and if none is present, will use chardet to attempt to guess the encoding. The only time Requests will not do this is if no explicit charset is present in the HTTP headersand the Content-Type header contains text. In this situation, RFC 2616 specifies that the default charset must be ISO-8859-1. Requests follows the specification in this case. If you require a different encoding, you can manually set the Response.encoding property, or use the rawResponse.content.&lt;/code>&lt;/p>&lt;p>然后我打印requests的response.encoding..结果是：&lt;/p>&lt;pre>&lt;code>ISO－8859-1&lt;/code>&lt;/pre>&lt;h2 id="解决">解决&lt;/h2>&lt;p>找到问题后直接&lt;/p>&lt;pre>&lt;code>response.encoding=&amp;quot;utf-8&amp;quot;&lt;/code>&lt;/pre>&lt;p>搞定&lt;/p></description></item><item><title>Pyspider Docker Deployment</title><link>https://laujay.com/posts/pyspider-docker-deployment/</link><pubDate>Mon, 18 Jul 2016 11:37:52 +0800</pubDate><guid>https://laujay.com/posts/pyspider-docker-deployment/</guid><description>&lt;h2 id="缘起">缘起&lt;/h2>&lt;p>最近在搞docker部署pyspider，pyspider是一个非常灵活用户友好的爬虫框架，基于该框架能够很容易写出可控的爬虫。由于对docker不够熟悉，花了不少时间在解决部署问题上，很多地方纠结了蛮久的。写点笔记记录使用经历。当然我最后还是没单机docker部署pyspider。。不过单机也用不着组件化。。&lt;/p>&lt;h2 id="首先将redis和postgresql启动">首先，将redis和postgresql启动&lt;/h2>&lt;pre>&lt;code># docker run --name postgres -v /data/postgres/:/var/lib/postgresql/data \-d -p $LOCAL_IP:5432:5432 -e POSTGRES_PASSWORD=&amp;quot;&amp;quot; postgres# docker run --name redis -d -p $LOCAL_IP:6379:6379 redis&lt;/code>&lt;/pre>&lt;h2 id="其次创建数据库用户和数据库">其次，创建数据库用户和数据库&lt;/h2>&lt;p>在实际部署中有个坑是这样的, docker-compose.yaml里db的用户名是由name@hostip里的name决定的，如果你没有创建name相应的role那么fetcher和processor会报错。创建完了role之后接着需要创建三个数据库taskdb,resultdb,projectdb。不会创建？&lt;/p>&lt;pre>&lt;code># docker exec -it postgres bash&lt;/code>&lt;/pre>&lt;p>然后在打开的容器shell里输入&lt;/p>&lt;pre>&lt;code>$ psql -U postgres&lt;/code>&lt;/pre>&lt;p>好剩下的增加root用户以及添加root所有的三个数据的postgresql操作可以看阮一峰的postgresql入门教程&lt;/p>&lt;h2 id="接着将调度器启动">接着，将调度器启动&lt;/h2>&lt;pre>&lt;code># docker run --name scheduler -d -p $LOCAL_IP:23333:23333 --restart=always binux/pyspider \--taskdb &amp;quot;sqlalchemy+postgresql+taskdb://binux@10.21.0.7/taskdb&amp;quot; \--resultdb &amp;quot;sqlalchemy+postgresql+resultdb://binux@10.21.0.7/resultdb&amp;quot; \--projectdb &amp;quot;sqlalchemy+postgresql+projectdb://binux@10.21.0.7/projectdb&amp;quot; \--message-queue &amp;quot;redis://10.21.0.7:6379&amp;quot; \&lt;/code>&lt;/pre>&lt;p>scheduler &amp;ndash;inqueue-limit 5000 &amp;ndash;delete-time 43200&lt;/p>&lt;p>这里的db的ip需要注意。我实际使用发现需要先&lt;code>docker exec -it postgres cat /etc/hosts&lt;/code> 看下容器内的ip然后写pgsql的ip，使用宿主机ip会有点问题。等我对docker更熟悉了估计能找出问题的解答。&lt;/p>&lt;p>还有个问题需要注意，调度器的&amp;ndash;message-quque的地址一定不能写错，如果写错那么就会出现单步你调试可以，但是一运行就会出现unknown project的情况。&lt;/p>&lt;pre>&lt;code>[E 160719 12:30:56 scheduler:238] unknown project: testdocker[I 160719 12:31:35 scheduler:505] in 5m: new:0,success:0,retry:0,failed:0[I 160719 12:32:35 scheduler:505] in 5m: new:0,success:0,retry:0,failed:0[I 160719 12:33:35 scheduler:505] in 5m: new:0,success:0,retry:0,failed:0[E 160719 12:33:44 scheduler:238] unknown project: test2[I 160719 12:34:35 scheduler:505] in 5m: new:0,success:0,retry:0,failed:0&lt;/code>&lt;/pre>&lt;h2 id="启动其它组件">启动其它组件&lt;/h2>&lt;p>在另外一台服务器使用docker-compose将其它组件启动启动&lt;code># docker-compose up&lt;/code>&lt;/p>&lt;p>compose.yaml的配置参照pyspider作者的&lt;a href="http://blog.binux.me/2016/05/deployment-of-demopyspiderorg/">部署博文&lt;/a>有删改我依据实际情况去掉了webui的负载均衡，以及改ip，改动不大，注意webui去掉负载均衡后需要自己将端口expose出来。&lt;/p></description></item><item><title>Docker基本使用</title><link>https://laujay.com/posts/docker-basic/</link><pubDate>Tue, 12 Jul 2016 09:13:45 +0800</pubDate><guid>https://laujay.com/posts/docker-basic/</guid><description>&lt;h2 id="docker使用笔记">docker使用笔记&lt;/h2>&lt;p>随用随记，并不成系统，主要是方便自己忘记的时候查阅。&lt;/p>&lt;h3 id="如何进入运行起来的docker-container">如何进入运行起来的docker container&lt;/h3>&lt;p>如果想要进去运行起来的container里看看日志什么的，那么使用docker 1.3之后添加的exec&lt;/p>&lt;pre>&lt;code>docker exec -i -t CONTAINER_ID bash&lt;/code>&lt;/pre>&lt;p>-i 其实是STDIN，也就是使用标准输入，这样你写的指令就能在容器里执行。-t 其实是tty的意思，就是使用终端，这样可以有个终端可以随时输入命令操作。&lt;/p>&lt;h3 id="查看log">查看log&lt;/h3>&lt;pre>&lt;code>docker log -f CONTAINTER_ID&lt;/code>&lt;/pre>&lt;h3 id="以及绝对路径">&lt;code>.&lt;/code>,&lt;code>./&lt;/code>,以及绝对路径&lt;/h3>&lt;p>写习惯了docker-compose.yaml就会出现一个问题: -v 给的路径写的时候常常会直接用相对路径&lt;code>.&lt;/code>或者&lt;code>./directory&lt;/code>，这在用yaml作为配置，用docker-compose编排叫起来docker组的时候是没有问题的, 解析yaml的时候会补全的。&lt;/p>&lt;p>但是直接用docker命令叫起单个container的时候那个值可是直接就给docker的，并不会解析补全路径，所以往往会报错。&lt;/p>&lt;p>所以之后养成的习惯就是直接用&lt;code>$(pwd)&lt;/code>这样可以避免出错，有时候忘了这茬还是会浪费点时间去看文档的。&lt;/p>&lt;h3 id="link-db-error">link db error&lt;/h3>&lt;p>习惯使用docker开发后，配置新项目的开发环境，经常会遇到的一个问题是数据库不存在。但是明明数据库那个docker，已经up了。其实原因很简单，docker link不可以&lt;code>refer to localhost&lt;/code>。而很多框架default的数据库的URI是localhost。在配置中将localhost改为DB那个container的名字就好了。&lt;/p>&lt;h3 id="删除退出的容器">删除退出的容器&lt;/h3>&lt;p>&lt;code>docker rm &lt;/code>docker ps -a |awk &amp;lsquo;{print $1}&amp;rsquo; | grep [0-9a-z]`&lt;/p>&lt;h3 id="删除none的镜像">删除none的镜像&lt;/h3>&lt;p>&lt;code>docker rmi $(docker images -f 'dangling=true' -q)&lt;/code>&lt;/p>&lt;h2 id="entrypoint">entrypoint&lt;/h2>&lt;p>今天在重新部署pyspider, 自己写了写代码利用框架，抽了个api出来，然而怎么放进docker里成了一个问题。一开始是直接mount一个文件夹进docker，然后进入docker，将代码复制进要的目录。准备重启进程的时候尴尬的事情发生了，docker-compose up起来的组件进程的pid是1，根本没办法kill掉再重启。&lt;/p>&lt;p>最后找到了docker-compose.yaml里command这一项，看完之后发现，都是参数。想了想去翻pyspider的Dockerfile，于是找了作者是怎么跑的:&lt;/p>&lt;pre>&lt;code>ENTRYPOINT ['pyspider']&lt;/code>&lt;/pre>&lt;p>找到了怎么跑的接下来就很简单了，首先写个shell，把原本作者写的命令以及参数都写进去，在这之上加入自己拷贝代码的shell语句。然后再在docker-compose.yaml里加上这么几行&lt;/p>&lt;pre>&lt;code>entrypoint: - bash - /code/replace.sh&lt;/code>&lt;/pre>&lt;p>然后再加个volume 把shell文件挂到docker的code目录就搞定了&lt;/p></description></item><item><title>Git手记</title><link>https://laujay.com/posts/git-note/</link><pubDate>Sun, 10 Jul 2016 18:32:28 +0800</pubDate><guid>https://laujay.com/posts/git-note/</guid><description>&lt;h2 id="经常碰到提交信息写错或者commit后临时又要添加文件的操作">经常碰到提交信息写错&amp;hellip;或者commit后临时又要添加文件的操作?&lt;/h2>&lt;p>那么可以这样：先提交forgotten_file&lt;/p>&lt;pre>&lt;code>$ git add forgoten_file&lt;/code>&lt;/pre>&lt;p>完了再&lt;/p>&lt;pre>&lt;code>$ git commit --amend&lt;/code>&lt;/pre>&lt;p>这样就可以把忘记的补上了，同时还可以修改说明&lt;/p>&lt;p>&lt;code>git commit --amend&lt;/code>命令需要的是提交的文件快照和之前一样，&lt;/p>&lt;p>所以上面的添加文件要在&lt;code>git commit&lt;/code>之前。&lt;/p>&lt;!-- raw HTML omitted -->&lt;h2 id="总有些文件会一不小心add进暂存区内取消暂存区的文件">总有些文件会一不小心add进暂存区内，取消暂存区的文件?&lt;/h2>&lt;p>在git status状态会有相应的信息提示，是git reset HEAD &lt;!-- raw HTML omitted -->&lt;/p>&lt;h2 id="已经commit了需要取消跟踪">已经commit了，需要取消跟踪？&lt;/h2>&lt;p>总有不小心跟踪了不该跟踪的文件的时候，这个时候需要从cached删除文件&lt;code>git rm --cached file&lt;/code>就派上用场了，如果是整个目录，那么这时候可以参考rm命令的参数。。 -rf 都派上用场了你没看错。。&lt;code>git rm -r --cached files/&lt;/code>极其好用。。整个文件夹都被干掉了。&lt;/p>&lt;h2 id="公司变土豪了买github私有库了">公司变土豪了，买github私有库了？&lt;/h2>&lt;p>转换仓库，从gitlab到github&lt;/p>&lt;p>&lt;code>git remote add upstream ssh://git@gitlab.xx.:workspace/project/pyclear.git&lt;/code>&lt;code>git remote set-url origin git@github.com:xxx/pyclear.git&lt;/code>&lt;/p>&lt;p>note: .git前的pyclear是Repositories，别误解&lt;/p>&lt;h2 id="想做点commit点省的误删但是那么多commit又很烦">想做点commit点省的误删，但是那么多commit又很烦？&lt;/h2>&lt;p>最近从&lt;a href="http://ajucs.com">阿驹&lt;/a>那学了一招&lt;/p>&lt;pre>&lt;code>git rebase -i 32db1a7e1....&lt;/code>&lt;/pre>&lt;p>先&lt;code>git log&lt;/code>找到你不想要保留的之前那个的hash，然后使用上面这条命令。就能进入一个编辑状态，然后再依据编辑状态的提示处理就ok了。很简单的。&lt;/p>&lt;h2 id="经常忘记你对当前的代码干了啥git操作">经常忘记你对当前的代码干了啥git操作?&lt;/h2>&lt;p>使用版本管理工具经常发生的一件事是，你对代码干了啥可以清楚的知道，但是维护过程中你使用了什么git操作，不知道了。这时候有几个做法，一个是history命令可以看出你之前的操作，但是如果时间久一点，那么命令一多你就难找了。&lt;code>git reflog&lt;/code>可以列出你之前的所有git操作，但是这个也是有时限的，好像是一个月，不过已经够了。&lt;/p>&lt;h2 id="代码出bug了不知道谁干的">代码出bug了。不知道谁干的？&lt;/h2>&lt;p>有时候会有冲突说，这bug是xxx写的，然后xxx不服。有版本管理很简单，能精确到某一行代码的作者是谁。&lt;code>git blame file&lt;/code>就能知道谁干的了。&lt;/p>&lt;h2 id="查看log想倒过来">查看log想倒过来？&lt;/h2>&lt;p>看代码的时候我喜欢一个commit看过去，但是有些commit多了log会很长于是log的参数&lt;code>--reverse&lt;/code>就派上用场了:&lt;code>git log --reverse&lt;/code>这命令会把commit按时间线从第一个开始递增展示&lt;/p>&lt;h2 id="只拉某一个分支">只拉某一个分支&lt;/h2>&lt;p>由于我将博客的md文件放在github博客仓库的dev分支，在外的时候不想把build好的html也搞下来所以要指定clone分支&lt;code>git clone -b &amp;lt;branch&amp;gt; &amp;lt;remote_repo&amp;gt;&lt;/code>&lt;/p>&lt;h2 id="分支重命名">分支重命名&lt;/h2>&lt;p>重命名分支&lt;code>git branch -m &amp;lt;oldname&amp;gt; &amp;lt;newname&amp;gt;&lt;/code>重命名当前分支&lt;code>git branch -m &amp;lt;newname&amp;gt;&lt;/code>&lt;/p>&lt;h2 id="命令行删除远程分支">命令行删除远程分支&lt;/h2>&lt;p>查看远程分支&lt;code>git branch -r &lt;/code>删除远程分支&lt;code>git push origin :want_delete_branch_name&lt;/code>&lt;/p>&lt;h2 id="拆分子模块并修改依赖">拆分子模块，并修改依赖&lt;/h2>&lt;p>&lt;code>git submodule add 仓库地址 路径&lt;/code>&lt;/p>&lt;p>git clone 的工程带有submodule时,因为并不会自动去拉取子模块需要执行：&lt;code>git submodule update --init --recursive&lt;/code>&lt;/p>&lt;h2 id="gitignore的写法">.gitignore的写法&lt;/h2>&lt;ul>&lt;li>所有空行或者以注释符号&lt;code>#&lt;/code>开头的都会被Git忽略&lt;/li>&lt;li>可以使用标准的glob模式匹配(shell所使用的简化略的正则表达式)&lt;/li>&lt;li>匹配模式最后跟反斜杠(&lt;code>/&lt;/code>)说明要忽略的是目录&lt;/li>&lt;li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号取反&lt;/li>&lt;/ul>&lt;h2 id="同步fork库">同步fork库&lt;/h2>&lt;p>经常会记不住同步的方式，特地记录下其实很简单&lt;code>git remote add upstream URL&lt;/code>&lt;code>git fetch upstream&lt;/code>&lt;code>git merge upstraem/upstream&lt;/code>&lt;/p></description></item><item><title>Ubuntu Bits Complie Bits Assembly</title><link>https://laujay.com/posts/ubuntu-bits-complie-bits-assembly/</link><pubDate>Fri, 08 Jul 2016 23:10:00 +0800</pubDate><guid>https://laujay.com/posts/ubuntu-bits-complie-bits-assembly/</guid><description>&lt;h2 id="64位ubuntu系统编译32位汇编">64位Ubuntu系统编译32位汇编&lt;/h2>&lt;h3 id="汇编链接生成可执行文件">汇编链接生成可执行文件&lt;/h3>&lt;pre>&lt;code>ld -o eatsyscall eatsycscall.o&lt;/code>&lt;/pre>&lt;h3 id="输出">输出&lt;/h3>&lt;p>&lt;em>ld:i386 architecture of input file &lt;code>eatsyscall.o' is incompatible with i386:x86-64 ouput&lt;/code>&lt;/em>&lt;/p>&lt;h3 id="解决">解决&lt;/h3>&lt;p>经过搜索64位下ld提供了一个选项-m emulation，简写-m。说明文档如下：&lt;/p>&lt;pre>&lt;code>-m emulation Emulate the emulation linker. You can list the available emulations with the --verbose or -V options. If the -m option is not used，the emulation is taken from the &amp;quot;LDEMULSYION&amp;quot; environment variable，if that is defined. Otherwise，the default emulation depends upon how the linker was configured.&lt;/code>&lt;/pre>&lt;p>即，这个选项可以模拟其他平台上的ld链接器。使用-m elf_i386可以模拟32位平台上ld指令。&lt;/p></description></item></channel></rss>